// Autogenerated by Thrift Compiler (0.15.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::server;

fn to_uint64(value: u64) -> Uint64 {
  return Uint64 {
      raw_value: Some(value.to_le_bytes().to_vec())
  };
}

fn to_fixed_array(v: Vec<u8>) -> [u8; 8] {
  v.try_into()
      .unwrap_or_else(|v: Vec<u8>| panic!("Expected a Vec of length {} but it was {}", 8, v.len()))
}

fn to_u64(value: Uint64) -> u64 {
  if value.raw_value.is_none() {
      panic!("bad raw Uint64 value 1");
  }
  return u64::from_le_bytes(to_fixed_array(value.raw_value.unwrap()));
}

impl From<u64> for Uint64 {
  fn from(value: u64) -> Uint64 {
      to_uint64(value)
  }
}

impl From<Uint64> for u64 {
  fn from(value: Uint64) -> u64 {
      to_u64(value)
  }
}


//
// TransactionException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TransactionException {
  pub exc: Option<String>,
}

impl TransactionException {
  pub fn new<F1>(exc: F1) -> TransactionException where F1: Into<Option<String>> {
    TransactionException {
      exc: exc.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransactionException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransactionException {
      exc: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransactionException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.exc {
      o_prot.write_field_begin(&TFieldIdentifier::new("exc", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TransactionException {
  fn default() -> Self {
    TransactionException{
      exc: Some("".to_owned()),
    }
  }
}

impl Error for TransactionException {}

impl From<TransactionException> for thrift::Error {
  fn from(e: TransactionException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TransactionException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw TransactionException")
  }
}

//
// AssertException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AssertException {
  pub error_message: Option<String>,
}

impl AssertException {
  pub fn new<F1>(error_message: F1) -> AssertException where F1: Into<Option<String>> {
    AssertException {
      error_message: error_message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AssertException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AssertException {
      error_message: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AssertException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.error_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("error_message", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AssertException {
  fn default() -> Self {
    AssertException{
      error_message: Some("".to_owned()),
    }
  }
}

impl Error for AssertException {}

impl From<AssertException> for thrift::Error {
  fn from(e: AssertException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for AssertException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw AssertException")
  }
}

//
// ActionArguments
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ActionArguments {
  RawArgs(Vec<u8>),
  JsonArgs(String),
}

impl ActionArguments {
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActionArguments> {
    let mut ret: Option<ActionArguments> = None;
    let mut received_field_count = 0;
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          if ret.is_none() {
            ret = Some(ActionArguments::RawArgs(val));
          }
          received_field_count += 1;
        },
        2 => {
          let val = i_prot.read_string()?;
          if ret.is_none() {
            ret = Some(ActionArguments::JsonArgs(val));
          }
          received_field_count += 1;
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
          received_field_count += 1;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    if received_field_count == 0 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received empty union from remote ActionArguments"
          )
        )
      )
    } else if received_field_count > 1 {
      Err(
        thrift::Error::Protocol(
          ProtocolError::new(
            ProtocolErrorKind::InvalidData,
            "received multiple fields for union from remote ActionArguments"
          )
        )
      )
    } else {
      Ok(ret.expect("return value should have been constructed"))
    }
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActionArguments");
    o_prot.write_struct_begin(&struct_ident)?;
    match *self {
      ActionArguments::RawArgs(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("raw_args", TType::String, 1))?;
        o_prot.write_bytes(f)?;
        o_prot.write_field_end()?;
      },
      ActionArguments::JsonArgs(ref f) => {
        o_prot.write_field_begin(&TFieldIdentifier::new("json_args", TType::String, 2))?;
        o_prot.write_string(f)?;
        o_prot.write_field_end()?;
      },
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Action
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Action {
  pub account: Option<String>,
  pub action: Option<String>,
  pub permissions: Option<String>,
  pub arguments: Option<ActionArguments>,
}

impl Action {
  pub fn new<F1, F2, F3, F4>(account: F1, action: F2, permissions: F3, arguments: F4) -> Action where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<ActionArguments>> {
    Action {
      account: account.into(),
      action: action.into(),
      permissions: permissions.into(),
      arguments: arguments.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Action> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<ActionArguments> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = ActionArguments::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Action {
      account: f_1,
      action: f_2,
      permissions: f_3,
      arguments: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Action");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.account {
      o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.action {
      o_prot.write_field_begin(&TFieldIdentifier::new("action", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.permissions {
      o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.arguments {
      o_prot.write_field_begin(&TFieldIdentifier::new("arguments", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Action {
  fn default() -> Self {
    Action{
      account: Some("".to_owned()),
      action: Some("".to_owned()),
      permissions: Some("".to_owned()),
      arguments: None,
    }
  }
}

//
// Uint64
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Uint64 {
  pub raw_value: Option<Vec<u8>>,
}

impl Uint64 {
  pub fn new<F1>(raw_value: F1) -> Uint64 where F1: Into<Option<Vec<u8>>> {
    Uint64 {
      raw_value: raw_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Uint64> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Uint64 {
      raw_value: f_1,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Uint64");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.raw_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("rawValue", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Uint64 {
  fn default() -> Self {
    Uint64{
      raw_value: Some(Vec::new()),
    }
  }
}

//
// DataBuffer
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataBuffer {
  pub size: Option<i32>,
  pub buffer: Option<Vec<u8>>,
}

impl DataBuffer {
  pub fn new<F1, F2>(size: F1, buffer: F2) -> DataBuffer where F1: Into<Option<i32>>, F2: Into<Option<Vec<u8>>> {
    DataBuffer {
      size: size.into(),
      buffer: buffer.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DataBuffer> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DataBuffer {
      size: f_1,
      buffer: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DataBuffer");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.size {
      o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.buffer {
      o_prot.write_field_begin(&TFieldIdentifier::new("buffer", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for DataBuffer {
  fn default() -> Self {
    DataBuffer{
      size: Some(0),
      buffer: Some(Vec::new()),
    }
  }
}

//
// NextPreviousReturn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NextPreviousReturn {
  pub iterator: Option<i32>,
  pub primary: Option<Uint64>,
}

impl NextPreviousReturn {
  pub fn new<F1, F2>(iterator: F1, primary: F2) -> NextPreviousReturn where F1: Into<Option<i32>>, F2: Into<Option<Uint64>> {
    NextPreviousReturn {
      iterator: iterator.into(),
      primary: primary.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<NextPreviousReturn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NextPreviousReturn {
      iterator: f_1,
      primary: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NextPreviousReturn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.iterator {
      o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.primary {
      o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NextPreviousReturn {
  fn default() -> Self {
    NextPreviousReturn{
      iterator: Some(0),
      primary: None,
    }
  }
}

//
// IteratorPrimaryReturn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IteratorPrimaryReturn {
  pub iterator: Option<i32>,
  pub primary: Option<Uint64>,
}

impl IteratorPrimaryReturn {
  pub fn new<F1, F2>(iterator: F1, primary: F2) -> IteratorPrimaryReturn where F1: Into<Option<i32>>, F2: Into<Option<Uint64>> {
    IteratorPrimaryReturn {
      iterator: iterator.into(),
      primary: primary.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IteratorPrimaryReturn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IteratorPrimaryReturn {
      iterator: f_1,
      primary: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IteratorPrimaryReturn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.iterator {
      o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.primary {
      o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for IteratorPrimaryReturn {
  fn default() -> Self {
    IteratorPrimaryReturn{
      iterator: Some(0),
      primary: None,
    }
  }
}

//
// FindPrimaryReturn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FindPrimaryReturn {
  pub iterator: Option<i32>,
  pub secondary: Option<Vec<u8>>,
}

impl FindPrimaryReturn {
  pub fn new<F1, F2>(iterator: F1, secondary: F2) -> FindPrimaryReturn where F1: Into<Option<i32>>, F2: Into<Option<Vec<u8>>> {
    FindPrimaryReturn {
      iterator: iterator.into(),
      secondary: secondary.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FindPrimaryReturn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FindPrimaryReturn {
      iterator: f_1,
      secondary: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FindPrimaryReturn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.iterator {
      o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.secondary {
      o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FindPrimaryReturn {
  fn default() -> Self {
    FindPrimaryReturn{
      iterator: Some(0),
      secondary: Some(Vec::new()),
    }
  }
}

//
// FindSecondaryReturn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FindSecondaryReturn {
  pub iterator: Option<i32>,
  pub primary: Option<Uint64>,
}

impl FindSecondaryReturn {
  pub fn new<F1, F2>(iterator: F1, primary: F2) -> FindSecondaryReturn where F1: Into<Option<i32>>, F2: Into<Option<Uint64>> {
    FindSecondaryReturn {
      iterator: iterator.into(),
      primary: primary.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FindSecondaryReturn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FindSecondaryReturn {
      iterator: f_1,
      primary: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FindSecondaryReturn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.iterator {
      o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.primary {
      o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FindSecondaryReturn {
  fn default() -> Self {
    FindSecondaryReturn{
      iterator: Some(0),
      primary: None,
    }
  }
}

//
// LowerBoundUpperBoundReturn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LowerBoundUpperBoundReturn {
  pub iterator: Option<i32>,
  pub secondary: Option<Vec<u8>>,
  pub primary: Option<Uint64>,
}

impl LowerBoundUpperBoundReturn {
  pub fn new<F1, F2, F3>(iterator: F1, secondary: F2, primary: F3) -> LowerBoundUpperBoundReturn where F1: Into<Option<i32>>, F2: Into<Option<Vec<u8>>>, F3: Into<Option<Uint64>> {
    LowerBoundUpperBoundReturn {
      iterator: iterator.into(),
      secondary: secondary.into(),
      primary: primary.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LowerBoundUpperBoundReturn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = LowerBoundUpperBoundReturn {
      iterator: f_1,
      secondary: f_2,
      primary: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LowerBoundUpperBoundReturn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.iterator {
      o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.secondary {
      o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.primary {
      o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for LowerBoundUpperBoundReturn {
  fn default() -> Self {
    LowerBoundUpperBoundReturn{
      iterator: Some(0),
      secondary: Some(Vec::new()),
      primary: None,
    }
  }
}

//
// GetResourceLimitsReturn
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetResourceLimitsReturn {
  pub ram_bytes: Option<i64>,
  pub net_weight: Option<i64>,
  pub cpu_weight: Option<i64>,
}

impl GetResourceLimitsReturn {
  pub fn new<F1, F2, F3>(ram_bytes: F1, net_weight: F2, cpu_weight: F3) -> GetResourceLimitsReturn where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    GetResourceLimitsReturn {
      ram_bytes: ram_bytes.into(),
      net_weight: net_weight.into(),
      cpu_weight: cpu_weight.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetResourceLimitsReturn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetResourceLimitsReturn {
      ram_bytes: f_1,
      net_weight: f_2,
      cpu_weight: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetResourceLimitsReturn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.ram_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("ram_bytes", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.net_weight {
      o_prot.write_field_begin(&TFieldIdentifier::new("net_weight", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cpu_weight {
      o_prot.write_field_begin(&TFieldIdentifier::new("cpu_weight", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GetResourceLimitsReturn {
  fn default() -> Self {
    GetResourceLimitsReturn{
      ram_bytes: Some(0),
      net_weight: Some(0),
      cpu_weight: Some(0),
    }
  }
}

//
// IPCChainTester service client
//

pub trait TIPCChainTesterSyncClient {
  fn init_vm_api(&mut self) -> thrift::Result<()>;
  fn init_apply_request(&mut self) -> thrift::Result<()>;
  fn set_native_contract(&mut self, id: i32, contract: String, dylib: String) -> thrift::Result<bool>;
  fn enable_debugging(&mut self, enable: bool) -> thrift::Result<()>;
  fn enable_debug_contract(&mut self, id: i32, contract: String, enable: bool) -> thrift::Result<()>;
  fn is_debug_contract_enabled(&mut self, id: i32, contract: String) -> thrift::Result<bool>;
  fn pack_abi(&mut self, abi: String) -> thrift::Result<Vec<u8>>;
  fn pack_action_args(&mut self, id: i32, contract: String, action: String, action_args: String) -> thrift::Result<Vec<u8>>;
  fn unpack_action_args(&mut self, id: i32, contract: String, action: String, raw_args: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn new_chain(&mut self, initialize: bool) -> thrift::Result<i32>;
  fn free_chain(&mut self, id: i32) -> thrift::Result<i32>;
  fn get_info(&mut self, id: i32) -> thrift::Result<String>;
  fn create_key(&mut self, key_type: String) -> thrift::Result<String>;
  fn get_account(&mut self, id: i32, account: String) -> thrift::Result<String>;
  fn create_account(&mut self, id: i32, creator: String, account: String, owner_key: String, active_key: String, ram_bytes: i64, stake_net: i64, stake_cpu: i64) -> thrift::Result<String>;
  fn import_key(&mut self, id: i32, pub_key: String, priv_key: String) -> thrift::Result<bool>;
  fn get_required_keys(&mut self, id: i32, transaction: String, available_keys: Vec<String>) -> thrift::Result<String>;
  fn produce_block(&mut self, id: i32, next_block_skip_seconds: i64) -> thrift::Result<()>;
  fn push_action(&mut self, id: i32, account: String, action: String, arguments: ActionArguments, permissions: String) -> thrift::Result<Vec<u8>>;
  fn push_actions(&mut self, id: i32, actions: Vec<Box<Action>>) -> thrift::Result<Vec<u8>>;
  fn deploy_contract(&mut self, id: i32, account: String, wasm: String, abi: String) -> thrift::Result<Vec<u8>>;
  fn get_table_rows(&mut self, id: i32, json: bool, code: String, scope: String, table: String, lower_bound: String, upper_bound: String, limit: i64, key_type: String, index_position: String, encode_type: String, reverse: bool, show_payer: bool) -> thrift::Result<String>;
}

pub trait TIPCChainTesterSyncClientMarker {}

pub struct IPCChainTesterSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> IPCChainTesterSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> IPCChainTesterSyncClient<IP, OP> {
    IPCChainTesterSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for IPCChainTesterSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TIPCChainTesterSyncClientMarker for IPCChainTesterSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TIPCChainTesterSyncClientMarker> TIPCChainTesterSyncClient for C {
  fn init_vm_api(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("init_vm_api", TMessageType::OneWay, self.sequence_number());
        let call_args = IPCChainTesterInitVmApiArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    Ok(())
  }
  fn init_apply_request(&mut self) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("init_apply_request", TMessageType::OneWay, self.sequence_number());
        let call_args = IPCChainTesterInitApplyRequestArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    Ok(())
  }
  fn set_native_contract(&mut self, id: i32, contract: String, dylib: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_native_contract", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterSetNativeContractArgs { id, contract, dylib };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_native_contract", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterSetNativeContractResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn enable_debugging(&mut self, enable: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("enable_debugging", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterEnableDebuggingArgs { enable };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("enable_debugging", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterEnableDebuggingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn enable_debug_contract(&mut self, id: i32, contract: String, enable: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("enable_debug_contract", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterEnableDebugContractArgs { id, contract, enable };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("enable_debug_contract", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterEnableDebugContractResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_debug_contract_enabled(&mut self, id: i32, contract: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("is_debug_contract_enabled", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterIsDebugContractEnabledArgs { id, contract };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("is_debug_contract_enabled", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterIsDebugContractEnabledResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn pack_abi(&mut self, abi: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("pack_abi", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterPackAbiArgs { abi };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("pack_abi", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterPackAbiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn pack_action_args(&mut self, id: i32, contract: String, action: String, action_args: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("pack_action_args", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterPackActionArgsArgs { id, contract, action, action_args };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("pack_action_args", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterPackActionArgsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unpack_action_args(&mut self, id: i32, contract: String, action: String, raw_args: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unpack_action_args", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterUnpackActionArgsArgs { id, contract, action, raw_args };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unpack_action_args", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterUnpackActionArgsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn new_chain(&mut self, initialize: bool) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("new_chain", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterNewChainArgs { initialize };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("new_chain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterNewChainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn free_chain(&mut self, id: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("free_chain", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterFreeChainArgs { id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("free_chain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterFreeChainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_info(&mut self, id: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_info", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterGetInfoArgs { id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_info", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterGetInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_key(&mut self, key_type: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_key", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterCreateKeyArgs { key_type };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterCreateKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_account(&mut self, id: i32, account: String) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_account", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterGetAccountArgs { id, account };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_account", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterGetAccountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_account(&mut self, id: i32, creator: String, account: String, owner_key: String, active_key: String, ram_bytes: i64, stake_net: i64, stake_cpu: i64) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("create_account", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterCreateAccountArgs { id, creator, account, owner_key, active_key, ram_bytes, stake_net, stake_cpu };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("create_account", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterCreateAccountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn import_key(&mut self, id: i32, pub_key: String, priv_key: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("import_key", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterImportKeyArgs { id, pub_key, priv_key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("import_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterImportKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_required_keys(&mut self, id: i32, transaction: String, available_keys: Vec<String>) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_required_keys", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterGetRequiredKeysArgs { id, transaction, available_keys };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_required_keys", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterGetRequiredKeysResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn produce_block(&mut self, id: i32, next_block_skip_seconds: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("produce_block", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterProduceBlockArgs { id, next_block_skip_seconds };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    server::run_apply_request_server()?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("produce_block", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterProduceBlockResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_action(&mut self, id: i32, account: String, action: String, arguments: ActionArguments, permissions: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("push_action", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterPushActionArgs { id, account, action, arguments, permissions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    server::run_apply_request_server()?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("push_action", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterPushActionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_actions(&mut self, id: i32, actions: Vec<Box<Action>>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterPushActionsArgs { id, actions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    server::run_apply_request_server()?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("push_actions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterPushActionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn deploy_contract(&mut self, id: i32, account: String, wasm: String, abi: String) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deploy_contract", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterDeployContractArgs { id, account, wasm, abi };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deploy_contract", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterDeployContractResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_table_rows(&mut self, id: i32, json: bool, code: String, scope: String, table: String, lower_bound: String, upper_bound: String, limit: i64, key_type: String, index_position: String, encode_type: String, reverse: bool, show_payer: bool) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_table_rows", TMessageType::Call, self.sequence_number());
        let call_args = IPCChainTesterGetTableRowsArgs { id, json, code, scope, table, lower_bound, upper_bound, limit, key_type, index_position, encode_type, reverse, show_payer };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_table_rows", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IPCChainTesterGetTableRowsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// IPCChainTester service processor
//

pub trait IPCChainTesterSyncHandler {
  fn handle_init_vm_api(&self) -> thrift::Result<()>;
  fn handle_init_apply_request(&self) -> thrift::Result<()>;
  fn handle_set_native_contract(&self, id: i32, contract: String, dylib: String) -> thrift::Result<bool>;
  fn handle_enable_debugging(&self, enable: bool) -> thrift::Result<()>;
  fn handle_enable_debug_contract(&self, id: i32, contract: String, enable: bool) -> thrift::Result<()>;
  fn handle_is_debug_contract_enabled(&self, id: i32, contract: String) -> thrift::Result<bool>;
  fn handle_pack_abi(&self, abi: String) -> thrift::Result<Vec<u8>>;
  fn handle_pack_action_args(&self, id: i32, contract: String, action: String, action_args: String) -> thrift::Result<Vec<u8>>;
  fn handle_unpack_action_args(&self, id: i32, contract: String, action: String, raw_args: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_new_chain(&self, initialize: bool) -> thrift::Result<i32>;
  fn handle_free_chain(&self, id: i32) -> thrift::Result<i32>;
  fn handle_get_info(&self, id: i32) -> thrift::Result<String>;
  fn handle_create_key(&self, key_type: String) -> thrift::Result<String>;
  fn handle_get_account(&self, id: i32, account: String) -> thrift::Result<String>;
  fn handle_create_account(&self, id: i32, creator: String, account: String, owner_key: String, active_key: String, ram_bytes: i64, stake_net: i64, stake_cpu: i64) -> thrift::Result<String>;
  fn handle_import_key(&self, id: i32, pub_key: String, priv_key: String) -> thrift::Result<bool>;
  fn handle_get_required_keys(&self, id: i32, transaction: String, available_keys: Vec<String>) -> thrift::Result<String>;
  fn handle_produce_block(&self, id: i32, next_block_skip_seconds: i64) -> thrift::Result<()>;
  fn handle_push_action(&self, id: i32, account: String, action: String, arguments: ActionArguments, permissions: String) -> thrift::Result<Vec<u8>>;
  fn handle_push_actions(&self, id: i32, actions: Vec<Box<Action>>) -> thrift::Result<Vec<u8>>;
  fn handle_deploy_contract(&self, id: i32, account: String, wasm: String, abi: String) -> thrift::Result<Vec<u8>>;
  fn handle_get_table_rows(&self, id: i32, json: bool, code: String, scope: String, table: String, lower_bound: String, upper_bound: String, limit: i64, key_type: String, index_position: String, encode_type: String, reverse: bool, show_payer: bool) -> thrift::Result<String>;
}

pub struct IPCChainTesterSyncProcessor<H: IPCChainTesterSyncHandler> {
  handler: H,
}

impl <H: IPCChainTesterSyncHandler> IPCChainTesterSyncProcessor<H> {
  pub fn new(handler: H) -> IPCChainTesterSyncProcessor<H> {
    IPCChainTesterSyncProcessor {
      handler,
    }
  }
  fn process_init_vm_api(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_init_vm_api(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_init_apply_request(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_init_apply_request(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_native_contract(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_set_native_contract(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_enable_debugging(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_enable_debugging(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_enable_debug_contract(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_enable_debug_contract(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_debug_contract_enabled(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_is_debug_contract_enabled(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_pack_abi(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_pack_abi(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_pack_action_args(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_pack_action_args(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unpack_action_args(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_unpack_action_args(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_new_chain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_new_chain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_free_chain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_free_chain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_get_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_create_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_account(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_get_account(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_account(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_create_account(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_import_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_import_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_required_keys(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_get_required_keys(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_produce_block(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_produce_block(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_action(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_push_action(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_actions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_push_actions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_deploy_contract(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_deploy_contract(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_table_rows(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIPCChainTesterProcessFunctions::process_get_table_rows(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TIPCChainTesterProcessFunctions;

impl TIPCChainTesterProcessFunctions {
  pub fn process_init_vm_api<H: IPCChainTesterSyncHandler>(handler: &H, _: i32, i_prot: &mut dyn TInputProtocol, _: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = IPCChainTesterInitVmApiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_init_vm_api() {
      Ok(_) => {
        Ok(())
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            Err(thrift::Error::Application(app_err))
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            Err(thrift::Error::Application(ret_err))
          },
        }
      },
    }
  }
  pub fn process_init_apply_request<H: IPCChainTesterSyncHandler>(handler: &H, _: i32, i_prot: &mut dyn TInputProtocol, _: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = IPCChainTesterInitApplyRequestArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_init_apply_request() {
      Ok(_) => {
        Ok(())
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            Err(thrift::Error::Application(app_err))
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            Err(thrift::Error::Application(ret_err))
          },
        }
      },
    }
  }
  pub fn process_set_native_contract<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterSetNativeContractArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_native_contract(args.id, args.contract, args.dylib) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_native_contract", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterSetNativeContractResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_native_contract", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_native_contract", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_enable_debugging<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterEnableDebuggingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_enable_debugging(args.enable) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("enable_debugging", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterEnableDebuggingResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("enable_debugging", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("enable_debugging", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_enable_debug_contract<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterEnableDebugContractArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_enable_debug_contract(args.id, args.contract, args.enable) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("enable_debug_contract", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterEnableDebugContractResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("enable_debug_contract", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("enable_debug_contract", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_debug_contract_enabled<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterIsDebugContractEnabledArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_debug_contract_enabled(args.id, args.contract) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("is_debug_contract_enabled", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterIsDebugContractEnabledResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("is_debug_contract_enabled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("is_debug_contract_enabled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_pack_abi<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterPackAbiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_pack_abi(args.abi) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("pack_abi", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterPackAbiResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("pack_abi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("pack_abi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_pack_action_args<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterPackActionArgsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_pack_action_args(args.id, args.contract, args.action, args.action_args) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("pack_action_args", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterPackActionArgsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("pack_action_args", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("pack_action_args", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unpack_action_args<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterUnpackActionArgsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unpack_action_args(args.id, args.contract, args.action, args.raw_args) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("unpack_action_args", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterUnpackActionArgsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unpack_action_args", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unpack_action_args", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_new_chain<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterNewChainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_new_chain(args.initialize) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("new_chain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterNewChainResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("new_chain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("new_chain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_free_chain<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterFreeChainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_free_chain(args.id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("free_chain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterFreeChainResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("free_chain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("free_chain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_info<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterGetInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_info(args.id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_info", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterGetInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_info", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_key<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterCreateKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_key(args.key_type) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterCreateKeyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_account<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterGetAccountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_account(args.id, args.account) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_account", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterGetAccountResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_account", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_account", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_account<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterCreateAccountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_account(args.id, args.creator, args.account, args.owner_key, args.active_key, args.ram_bytes, args.stake_net, args.stake_cpu) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("create_account", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterCreateAccountResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("create_account", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("create_account", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_import_key<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterImportKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_import_key(args.id, args.pub_key, args.priv_key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("import_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterImportKeyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("import_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("import_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_required_keys<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterGetRequiredKeysArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_required_keys(args.id, args.transaction, args.available_keys) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_required_keys", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterGetRequiredKeysResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_required_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_required_keys", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_produce_block<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterProduceBlockArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_produce_block(args.id, args.next_block_skip_seconds) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("produce_block", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterProduceBlockResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("produce_block", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("produce_block", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_action<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterPushActionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_action(args.id, args.account, args.action, args.arguments, args.permissions) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("push_action", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterPushActionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("push_action", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("push_action", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_actions<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterPushActionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_actions(args.id, args.actions) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterPushActionsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_deploy_contract<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterDeployContractArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_deploy_contract(args.id, args.account, args.wasm, args.abi) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deploy_contract", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterDeployContractResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deploy_contract", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deploy_contract", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_table_rows<H: IPCChainTesterSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IPCChainTesterGetTableRowsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_table_rows(args.id, args.json, args.code, args.scope, args.table, args.lower_bound, args.upper_bound, args.limit, args.key_type, args.index_position, args.encode_type, args.reverse, args.show_payer) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_table_rows", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IPCChainTesterGetTableRowsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_table_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_table_rows", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: IPCChainTesterSyncHandler> TProcessor for IPCChainTesterSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "init_vm_api" => {
        self.process_init_vm_api(message_ident.sequence_number, i_prot, o_prot)
      },
      "init_apply_request" => {
        self.process_init_apply_request(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_native_contract" => {
        self.process_set_native_contract(message_ident.sequence_number, i_prot, o_prot)
      },
      "enable_debugging" => {
        self.process_enable_debugging(message_ident.sequence_number, i_prot, o_prot)
      },
      "enable_debug_contract" => {
        self.process_enable_debug_contract(message_ident.sequence_number, i_prot, o_prot)
      },
      "is_debug_contract_enabled" => {
        self.process_is_debug_contract_enabled(message_ident.sequence_number, i_prot, o_prot)
      },
      "pack_abi" => {
        self.process_pack_abi(message_ident.sequence_number, i_prot, o_prot)
      },
      "pack_action_args" => {
        self.process_pack_action_args(message_ident.sequence_number, i_prot, o_prot)
      },
      "unpack_action_args" => {
        self.process_unpack_action_args(message_ident.sequence_number, i_prot, o_prot)
      },
      "new_chain" => {
        self.process_new_chain(message_ident.sequence_number, i_prot, o_prot)
      },
      "free_chain" => {
        self.process_free_chain(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_info" => {
        self.process_get_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_key" => {
        self.process_create_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_account" => {
        self.process_get_account(message_ident.sequence_number, i_prot, o_prot)
      },
      "create_account" => {
        self.process_create_account(message_ident.sequence_number, i_prot, o_prot)
      },
      "import_key" => {
        self.process_import_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_required_keys" => {
        self.process_get_required_keys(message_ident.sequence_number, i_prot, o_prot)
      },
      "produce_block" => {
        self.process_produce_block(message_ident.sequence_number, i_prot, o_prot)
      },
      "push_action" => {
        self.process_push_action(message_ident.sequence_number, i_prot, o_prot)
      },
      "push_actions" => {
        self.process_push_actions(message_ident.sequence_number, i_prot, o_prot)
      },
      "deploy_contract" => {
        self.process_deploy_contract(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_table_rows" => {
        self.process_get_table_rows(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// IPCChainTesterInitVmApiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterInitVmApiArgs {
}

impl IPCChainTesterInitVmApiArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterInitVmApiArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterInitVmApiArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("init_vm_api_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterInitApplyRequestArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterInitApplyRequestArgs {
}

impl IPCChainTesterInitApplyRequestArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterInitApplyRequestArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterInitApplyRequestArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("init_apply_request_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterSetNativeContractArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterSetNativeContractArgs {
  id: i32,
  contract: String,
  dylib: String,
}

impl IPCChainTesterSetNativeContractArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterSetNativeContractArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterSetNativeContractArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterSetNativeContractArgs.contract", &f_2)?;
    verify_required_field_exists("IPCChainTesterSetNativeContractArgs.dylib", &f_3)?;
    let ret = IPCChainTesterSetNativeContractArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contract: f_2.expect("auto-generated code should have checked for presence of required fields"),
      dylib: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_native_contract_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contract", TType::String, 2))?;
    o_prot.write_string(&self.contract)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dylib", TType::String, 3))?;
    o_prot.write_string(&self.dylib)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterSetNativeContractResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterSetNativeContractResult {
  result_value: Option<bool>,
}

impl IPCChainTesterSetNativeContractResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterSetNativeContractResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterSetNativeContractResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterSetNativeContractResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterSetNativeContract"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterEnableDebuggingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterEnableDebuggingArgs {
  enable: bool,
}

impl IPCChainTesterEnableDebuggingArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterEnableDebuggingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterEnableDebuggingArgs.enable", &f_1)?;
    let ret = IPCChainTesterEnableDebuggingArgs {
      enable: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("enable_debugging_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("enable", TType::Bool, 1))?;
    o_prot.write_bool(self.enable)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterEnableDebuggingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterEnableDebuggingResult {
}

impl IPCChainTesterEnableDebuggingResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterEnableDebuggingResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterEnableDebuggingResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterEnableDebuggingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// IPCChainTesterEnableDebugContractArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterEnableDebugContractArgs {
  id: i32,
  contract: String,
  enable: bool,
}

impl IPCChainTesterEnableDebugContractArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterEnableDebugContractArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterEnableDebugContractArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterEnableDebugContractArgs.contract", &f_2)?;
    verify_required_field_exists("IPCChainTesterEnableDebugContractArgs.enable", &f_3)?;
    let ret = IPCChainTesterEnableDebugContractArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contract: f_2.expect("auto-generated code should have checked for presence of required fields"),
      enable: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("enable_debug_contract_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contract", TType::String, 2))?;
    o_prot.write_string(&self.contract)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("enable", TType::Bool, 3))?;
    o_prot.write_bool(self.enable)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterEnableDebugContractResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterEnableDebugContractResult {
}

impl IPCChainTesterEnableDebugContractResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterEnableDebugContractResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterEnableDebugContractResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterEnableDebugContractResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// IPCChainTesterIsDebugContractEnabledArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterIsDebugContractEnabledArgs {
  id: i32,
  contract: String,
}

impl IPCChainTesterIsDebugContractEnabledArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterIsDebugContractEnabledArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterIsDebugContractEnabledArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterIsDebugContractEnabledArgs.contract", &f_2)?;
    let ret = IPCChainTesterIsDebugContractEnabledArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contract: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("is_debug_contract_enabled_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contract", TType::String, 2))?;
    o_prot.write_string(&self.contract)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterIsDebugContractEnabledResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterIsDebugContractEnabledResult {
  result_value: Option<bool>,
}

impl IPCChainTesterIsDebugContractEnabledResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterIsDebugContractEnabledResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterIsDebugContractEnabledResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterIsDebugContractEnabledResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterIsDebugContractEnabled"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterPackAbiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPackAbiArgs {
  abi: String,
}

impl IPCChainTesterPackAbiArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPackAbiArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterPackAbiArgs.abi", &f_1)?;
    let ret = IPCChainTesterPackAbiArgs {
      abi: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("pack_abi_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("abi", TType::String, 1))?;
    o_prot.write_string(&self.abi)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterPackAbiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPackAbiResult {
  result_value: Option<Vec<u8>>,
}

impl IPCChainTesterPackAbiResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPackAbiResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterPackAbiResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterPackAbiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterPackAbi"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterPackActionArgsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPackActionArgsArgs {
  id: i32,
  contract: String,
  action: String,
  action_args: String,
}

impl IPCChainTesterPackActionArgsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPackActionArgsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterPackActionArgsArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterPackActionArgsArgs.contract", &f_2)?;
    verify_required_field_exists("IPCChainTesterPackActionArgsArgs.action", &f_3)?;
    verify_required_field_exists("IPCChainTesterPackActionArgsArgs.action_args", &f_4)?;
    let ret = IPCChainTesterPackActionArgsArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contract: f_2.expect("auto-generated code should have checked for presence of required fields"),
      action: f_3.expect("auto-generated code should have checked for presence of required fields"),
      action_args: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("pack_action_args_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contract", TType::String, 2))?;
    o_prot.write_string(&self.contract)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("action", TType::String, 3))?;
    o_prot.write_string(&self.action)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("action_args", TType::String, 4))?;
    o_prot.write_string(&self.action_args)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterPackActionArgsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPackActionArgsResult {
  result_value: Option<Vec<u8>>,
}

impl IPCChainTesterPackActionArgsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPackActionArgsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterPackActionArgsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterPackActionArgsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterPackActionArgs"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterUnpackActionArgsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterUnpackActionArgsArgs {
  id: i32,
  contract: String,
  action: String,
  raw_args: Vec<u8>,
}

impl IPCChainTesterUnpackActionArgsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterUnpackActionArgsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterUnpackActionArgsArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterUnpackActionArgsArgs.contract", &f_2)?;
    verify_required_field_exists("IPCChainTesterUnpackActionArgsArgs.action", &f_3)?;
    verify_required_field_exists("IPCChainTesterUnpackActionArgsArgs.raw_args", &f_4)?;
    let ret = IPCChainTesterUnpackActionArgsArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contract: f_2.expect("auto-generated code should have checked for presence of required fields"),
      action: f_3.expect("auto-generated code should have checked for presence of required fields"),
      raw_args: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unpack_action_args_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contract", TType::String, 2))?;
    o_prot.write_string(&self.contract)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("action", TType::String, 3))?;
    o_prot.write_string(&self.action)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("raw_args", TType::String, 4))?;
    o_prot.write_bytes(&self.raw_args)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterUnpackActionArgsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterUnpackActionArgsResult {
  result_value: Option<Vec<u8>>,
}

impl IPCChainTesterUnpackActionArgsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterUnpackActionArgsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterUnpackActionArgsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterUnpackActionArgsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterUnpackActionArgs"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterNewChainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterNewChainArgs {
  initialize: bool,
}

impl IPCChainTesterNewChainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterNewChainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterNewChainArgs.initialize", &f_1)?;
    let ret = IPCChainTesterNewChainArgs {
      initialize: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("new_chain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("initialize", TType::Bool, 1))?;
    o_prot.write_bool(self.initialize)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterNewChainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterNewChainResult {
  result_value: Option<i32>,
}

impl IPCChainTesterNewChainResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterNewChainResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterNewChainResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterNewChainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterNewChain"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterFreeChainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterFreeChainArgs {
  id: i32,
}

impl IPCChainTesterFreeChainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterFreeChainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterFreeChainArgs.id", &f_1)?;
    let ret = IPCChainTesterFreeChainArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("free_chain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterFreeChainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterFreeChainResult {
  result_value: Option<i32>,
}

impl IPCChainTesterFreeChainResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterFreeChainResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterFreeChainResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterFreeChainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterFreeChain"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterGetInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetInfoArgs {
  id: i32,
}

impl IPCChainTesterGetInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterGetInfoArgs.id", &f_1)?;
    let ret = IPCChainTesterGetInfoArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_info_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterGetInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetInfoResult {
  result_value: Option<String>,
}

impl IPCChainTesterGetInfoResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterGetInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterGetInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterGetInfo"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterCreateKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterCreateKeyArgs {
  key_type: String,
}

impl IPCChainTesterCreateKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterCreateKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterCreateKeyArgs.key_type", &f_1)?;
    let ret = IPCChainTesterCreateKeyArgs {
      key_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_type", TType::String, 1))?;
    o_prot.write_string(&self.key_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterCreateKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterCreateKeyResult {
  result_value: Option<String>,
}

impl IPCChainTesterCreateKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterCreateKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterCreateKeyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterCreateKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterCreateKey"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterGetAccountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetAccountArgs {
  id: i32,
  account: String,
}

impl IPCChainTesterGetAccountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetAccountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterGetAccountArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterGetAccountArgs.account", &f_2)?;
    let ret = IPCChainTesterGetAccountArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      account: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_account_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::String, 2))?;
    o_prot.write_string(&self.account)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterGetAccountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetAccountResult {
  result_value: Option<String>,
}

impl IPCChainTesterGetAccountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetAccountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterGetAccountResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterGetAccountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterGetAccount"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterCreateAccountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterCreateAccountArgs {
  id: i32,
  creator: String,
  account: String,
  owner_key: String,
  active_key: String,
  ram_bytes: i64,
  stake_net: i64,
  stake_cpu: i64,
}

impl IPCChainTesterCreateAccountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterCreateAccountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.creator", &f_2)?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.account", &f_3)?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.owner_key", &f_4)?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.active_key", &f_5)?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.ram_bytes", &f_6)?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.stake_net", &f_7)?;
    verify_required_field_exists("IPCChainTesterCreateAccountArgs.stake_cpu", &f_8)?;
    let ret = IPCChainTesterCreateAccountArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      creator: f_2.expect("auto-generated code should have checked for presence of required fields"),
      account: f_3.expect("auto-generated code should have checked for presence of required fields"),
      owner_key: f_4.expect("auto-generated code should have checked for presence of required fields"),
      active_key: f_5.expect("auto-generated code should have checked for presence of required fields"),
      ram_bytes: f_6.expect("auto-generated code should have checked for presence of required fields"),
      stake_net: f_7.expect("auto-generated code should have checked for presence of required fields"),
      stake_cpu: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("create_account_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("creator", TType::String, 2))?;
    o_prot.write_string(&self.creator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::String, 3))?;
    o_prot.write_string(&self.account)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("owner_key", TType::String, 4))?;
    o_prot.write_string(&self.owner_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("active_key", TType::String, 5))?;
    o_prot.write_string(&self.active_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ram_bytes", TType::I64, 6))?;
    o_prot.write_i64(self.ram_bytes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stake_net", TType::I64, 7))?;
    o_prot.write_i64(self.stake_net)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("stake_cpu", TType::I64, 8))?;
    o_prot.write_i64(self.stake_cpu)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterCreateAccountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterCreateAccountResult {
  result_value: Option<String>,
}

impl IPCChainTesterCreateAccountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterCreateAccountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterCreateAccountResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterCreateAccountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterCreateAccount"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterImportKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterImportKeyArgs {
  id: i32,
  pub_key: String,
  priv_key: String,
}

impl IPCChainTesterImportKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterImportKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterImportKeyArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterImportKeyArgs.pub_key", &f_2)?;
    verify_required_field_exists("IPCChainTesterImportKeyArgs.priv_key", &f_3)?;
    let ret = IPCChainTesterImportKeyArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pub_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      priv_key: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("import_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pub_key", TType::String, 2))?;
    o_prot.write_string(&self.pub_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("priv_key", TType::String, 3))?;
    o_prot.write_string(&self.priv_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterImportKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterImportKeyResult {
  result_value: Option<bool>,
}

impl IPCChainTesterImportKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterImportKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterImportKeyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterImportKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterImportKey"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterGetRequiredKeysArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetRequiredKeysArgs {
  id: i32,
  transaction: String,
  available_keys: Vec<String>,
}

impl IPCChainTesterGetRequiredKeysArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetRequiredKeysArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterGetRequiredKeysArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterGetRequiredKeysArgs.transaction", &f_2)?;
    verify_required_field_exists("IPCChainTesterGetRequiredKeysArgs.available_keys", &f_3)?;
    let ret = IPCChainTesterGetRequiredKeysArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      transaction: f_2.expect("auto-generated code should have checked for presence of required fields"),
      available_keys: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_required_keys_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("transaction", TType::String, 2))?;
    o_prot.write_string(&self.transaction)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("available_keys", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.available_keys.len() as i32))?;
    for e in &self.available_keys {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterGetRequiredKeysResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetRequiredKeysResult {
  result_value: Option<String>,
}

impl IPCChainTesterGetRequiredKeysResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetRequiredKeysResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterGetRequiredKeysResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterGetRequiredKeysResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterGetRequiredKeys"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterProduceBlockArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterProduceBlockArgs {
  id: i32,
  next_block_skip_seconds: i64,
}

impl IPCChainTesterProduceBlockArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterProduceBlockArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterProduceBlockArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterProduceBlockArgs.next_block_skip_seconds", &f_2)?;
    let ret = IPCChainTesterProduceBlockArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      next_block_skip_seconds: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("produce_block_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("next_block_skip_seconds", TType::I64, 2))?;
    o_prot.write_i64(self.next_block_skip_seconds)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterProduceBlockResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterProduceBlockResult {
}

impl IPCChainTesterProduceBlockResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterProduceBlockResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterProduceBlockResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterProduceBlockResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// IPCChainTesterPushActionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPushActionArgs {
  id: i32,
  account: String,
  action: String,
  arguments: ActionArguments,
  permissions: String,
}

impl IPCChainTesterPushActionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPushActionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<ActionArguments> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = ActionArguments::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterPushActionArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterPushActionArgs.account", &f_2)?;
    verify_required_field_exists("IPCChainTesterPushActionArgs.action", &f_3)?;
    verify_required_field_exists("IPCChainTesterPushActionArgs.arguments", &f_4)?;
    verify_required_field_exists("IPCChainTesterPushActionArgs.permissions", &f_5)?;
    let ret = IPCChainTesterPushActionArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      account: f_2.expect("auto-generated code should have checked for presence of required fields"),
      action: f_3.expect("auto-generated code should have checked for presence of required fields"),
      arguments: f_4.expect("auto-generated code should have checked for presence of required fields"),
      permissions: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("push_action_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::String, 2))?;
    o_prot.write_string(&self.account)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("action", TType::String, 3))?;
    o_prot.write_string(&self.action)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("arguments", TType::Struct, 4))?;
    self.arguments.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permissions", TType::String, 5))?;
    o_prot.write_string(&self.permissions)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterPushActionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPushActionResult {
  result_value: Option<Vec<u8>>,
}

impl IPCChainTesterPushActionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPushActionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterPushActionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterPushActionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterPushAction"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterPushActionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPushActionsArgs {
  id: i32,
  actions: Vec<Box<Action>>,
}

impl IPCChainTesterPushActionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPushActionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Vec<Box<Action>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<Action>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = Box::new(Action::read_from_in_protocol(i_prot)?);
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterPushActionsArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterPushActionsArgs.actions", &f_2)?;
    let ret = IPCChainTesterPushActionsArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      actions: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("push_actions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("actions", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.actions.len() as i32))?;
    for e in &self.actions {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterPushActionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterPushActionsResult {
  result_value: Option<Vec<u8>>,
}

impl IPCChainTesterPushActionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterPushActionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterPushActionsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterPushActionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterPushActions"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterDeployContractArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterDeployContractArgs {
  id: i32,
  account: String,
  wasm: String,
  abi: String,
}

impl IPCChainTesterDeployContractArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterDeployContractArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterDeployContractArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterDeployContractArgs.account", &f_2)?;
    verify_required_field_exists("IPCChainTesterDeployContractArgs.wasm", &f_3)?;
    verify_required_field_exists("IPCChainTesterDeployContractArgs.abi", &f_4)?;
    let ret = IPCChainTesterDeployContractArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      account: f_2.expect("auto-generated code should have checked for presence of required fields"),
      wasm: f_3.expect("auto-generated code should have checked for presence of required fields"),
      abi: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deploy_contract_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::String, 2))?;
    o_prot.write_string(&self.account)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("wasm", TType::String, 3))?;
    o_prot.write_string(&self.wasm)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("abi", TType::String, 4))?;
    o_prot.write_string(&self.abi)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterDeployContractResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterDeployContractResult {
  result_value: Option<Vec<u8>>,
}

impl IPCChainTesterDeployContractResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterDeployContractResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterDeployContractResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterDeployContractResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterDeployContract"
          )
        )
      )
    }
  }
}

//
// IPCChainTesterGetTableRowsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetTableRowsArgs {
  id: i32,
  json: bool,
  code: String,
  scope: String,
  table: String,
  lower_bound: String,
  upper_bound: String,
  limit: i64,
  key_type: String,
  index_position: String,
  encode_type: String,
  reverse: bool,
  show_payer: bool,
}

impl IPCChainTesterGetTableRowsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetTableRowsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<String> = None;
    let mut f_10: Option<String> = None;
    let mut f_11: Option<String> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.id", &f_1)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.json", &f_2)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.code", &f_3)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.scope", &f_4)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.table", &f_5)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.lower_bound", &f_6)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.upper_bound", &f_7)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.limit", &f_8)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.key_type", &f_9)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.index_position", &f_10)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.encode_type", &f_11)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.reverse", &f_12)?;
    verify_required_field_exists("IPCChainTesterGetTableRowsArgs.show_payer", &f_13)?;
    let ret = IPCChainTesterGetTableRowsArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      code: f_3.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_4.expect("auto-generated code should have checked for presence of required fields"),
      table: f_5.expect("auto-generated code should have checked for presence of required fields"),
      lower_bound: f_6.expect("auto-generated code should have checked for presence of required fields"),
      upper_bound: f_7.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_8.expect("auto-generated code should have checked for presence of required fields"),
      key_type: f_9.expect("auto-generated code should have checked for presence of required fields"),
      index_position: f_10.expect("auto-generated code should have checked for presence of required fields"),
      encode_type: f_11.expect("auto-generated code should have checked for presence of required fields"),
      reverse: f_12.expect("auto-generated code should have checked for presence of required fields"),
      show_payer: f_13.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_table_rows_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 1))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("json", TType::Bool, 2))?;
    o_prot.write_bool(self.json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::String, 3))?;
    o_prot.write_string(&self.code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::String, 4))?;
    o_prot.write_string(&self.scope)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::String, 5))?;
    o_prot.write_string(&self.table)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lower_bound", TType::String, 6))?;
    o_prot.write_string(&self.lower_bound)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("upper_bound", TType::String, 7))?;
    o_prot.write_string(&self.upper_bound)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I64, 8))?;
    o_prot.write_i64(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key_type", TType::String, 9))?;
    o_prot.write_string(&self.key_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index_position", TType::String, 10))?;
    o_prot.write_string(&self.index_position)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encode_type", TType::String, 11))?;
    o_prot.write_string(&self.encode_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reverse", TType::Bool, 12))?;
    o_prot.write_bool(self.reverse)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show_payer", TType::Bool, 13))?;
    o_prot.write_bool(self.show_payer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IPCChainTesterGetTableRowsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IPCChainTesterGetTableRowsResult {
  result_value: Option<String>,
}

impl IPCChainTesterGetTableRowsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IPCChainTesterGetTableRowsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IPCChainTesterGetTableRowsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IPCChainTesterGetTableRowsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IPCChainTesterGetTableRows"
          )
        )
      )
    }
  }
}

//
// PushActions service client
//

pub trait TPushActionsSyncClient {
  fn push_actions(&mut self, actions: Vec<Action>) -> thrift::Result<i32>;
}

pub trait TPushActionsSyncClientMarker {}

pub struct PushActionsSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> PushActionsSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> PushActionsSyncClient<IP, OP> {
    PushActionsSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for PushActionsSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TPushActionsSyncClientMarker for PushActionsSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TPushActionsSyncClientMarker> TPushActionsSyncClient for C {
  fn push_actions(&mut self, actions: Vec<Action>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Call, self.sequence_number());
        let call_args = PushActionsPushActionsArgs { actions };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("push_actions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = PushActionsPushActionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// PushActions service processor
//

pub trait PushActionsSyncHandler {
  fn handle_push_actions(&self, actions: Vec<Action>) -> thrift::Result<i32>;
}

pub struct PushActionsSyncProcessor<H: PushActionsSyncHandler> {
  handler: H,
}

impl <H: PushActionsSyncHandler> PushActionsSyncProcessor<H> {
  pub fn new(handler: H) -> PushActionsSyncProcessor<H> {
    PushActionsSyncProcessor {
      handler,
    }
  }
  fn process_push_actions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TPushActionsProcessFunctions::process_push_actions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TPushActionsProcessFunctions;

impl TPushActionsProcessFunctions {
  pub fn process_push_actions<H: PushActionsSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = PushActionsPushActionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_actions(args.actions) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = PushActionsPushActionsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("push_actions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: PushActionsSyncHandler> TProcessor for PushActionsSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "push_actions" => {
        self.process_push_actions(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// PushActionsPushActionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct PushActionsPushActionsArgs {
  actions: Vec<Action>,
}

impl PushActionsPushActionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PushActionsPushActionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Action>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Action> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = Action::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("PushActionsPushActionsArgs.actions", &f_1)?;
    let ret = PushActionsPushActionsArgs {
      actions: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("push_actions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("actions", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.actions.len() as i32))?;
    for e in &self.actions {
      e.write_to_out_protocol(o_prot)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PushActionsPushActionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct PushActionsPushActionsResult {
  result_value: Option<i32>,
}

impl PushActionsPushActionsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PushActionsPushActionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PushActionsPushActionsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushActionsPushActionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for PushActionsPushActions"
          )
        )
      )
    }
  }
}

//
// ApplyRequest service client
//

pub trait TApplyRequestSyncClient {
  fn apply_request(&mut self, receiver: Uint64, first_receiver: Uint64, action: Uint64, chain_tester_id: i32) -> thrift::Result<i32>;
  fn apply_end(&mut self, chain_tester_id: i32) -> thrift::Result<i32>;
}

pub trait TApplyRequestSyncClientMarker {}

pub struct ApplyRequestSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ApplyRequestSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ApplyRequestSyncClient<IP, OP> {
    ApplyRequestSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ApplyRequestSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TApplyRequestSyncClientMarker for ApplyRequestSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TApplyRequestSyncClientMarker> TApplyRequestSyncClient for C {
  fn apply_request(&mut self, receiver: Uint64, first_receiver: Uint64, action: Uint64, chain_tester_id: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("apply_request", TMessageType::Call, self.sequence_number());
        let call_args = ApplyRequestApplyRequestArgs { receiver, first_receiver, action, chain_tester_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("apply_request", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyRequestApplyRequestResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn apply_end(&mut self, chain_tester_id: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("apply_end", TMessageType::Call, self.sequence_number());
        let call_args = ApplyRequestApplyEndArgs { chain_tester_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("apply_end", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyRequestApplyEndResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// ApplyRequest service processor
//

pub trait ApplyRequestSyncHandler {
  fn handle_apply_request(&self, receiver: Uint64, first_receiver: Uint64, action: Uint64, chain_tester_id: i32) -> thrift::Result<i32>;
  fn handle_apply_end(&self, chain_tester_id: i32) -> thrift::Result<i32>;
}

pub struct ApplyRequestSyncProcessor<H: ApplyRequestSyncHandler> {
  handler: H,
}

impl <H: ApplyRequestSyncHandler> ApplyRequestSyncProcessor<H> {
  pub fn new(handler: H) -> ApplyRequestSyncProcessor<H> {
    ApplyRequestSyncProcessor {
      handler,
    }
  }
  fn process_apply_request(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyRequestProcessFunctions::process_apply_request(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_apply_end(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyRequestProcessFunctions::process_apply_end(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TApplyRequestProcessFunctions;

impl TApplyRequestProcessFunctions {
  pub fn process_apply_request<H: ApplyRequestSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyRequestApplyRequestArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_apply_request(args.receiver, args.first_receiver, args.action, args.chain_tester_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("apply_request", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyRequestApplyRequestResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("apply_request", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("apply_request", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_apply_end<H: ApplyRequestSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyRequestApplyEndArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_apply_end(args.chain_tester_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("apply_end", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyRequestApplyEndResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("apply_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("apply_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ApplyRequestSyncHandler> TProcessor for ApplyRequestSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "apply_request" => {
        self.process_apply_request(message_ident.sequence_number, i_prot, o_prot)
      },
      "apply_end" => {
        self.process_apply_end(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ApplyRequestApplyRequestArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequestApplyRequestArgs {
  receiver: Uint64,
  first_receiver: Uint64,
  action: Uint64,
  chain_tester_id: i32,
}

impl ApplyRequestApplyRequestArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequestApplyRequestArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyRequestApplyRequestArgs.receiver", &f_1)?;
    verify_required_field_exists("ApplyRequestApplyRequestArgs.first_receiver", &f_2)?;
    verify_required_field_exists("ApplyRequestApplyRequestArgs.action", &f_3)?;
    verify_required_field_exists("ApplyRequestApplyRequestArgs.chain_tester_id", &f_4)?;
    let ret = ApplyRequestApplyRequestArgs {
      receiver: f_1.expect("auto-generated code should have checked for presence of required fields"),
      first_receiver: f_2.expect("auto-generated code should have checked for presence of required fields"),
      action: f_3.expect("auto-generated code should have checked for presence of required fields"),
      chain_tester_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("apply_request_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receiver", TType::Struct, 1))?;
    self.receiver.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("firstReceiver", TType::Struct, 2))?;
    self.first_receiver.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("action", TType::Struct, 3))?;
    self.action.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("chainTesterId", TType::I32, 4))?;
    o_prot.write_i32(self.chain_tester_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyRequestApplyRequestResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequestApplyRequestResult {
  result_value: Option<i32>,
}

impl ApplyRequestApplyRequestResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequestApplyRequestResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyRequestApplyRequestResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyRequestApplyRequestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyRequestApplyRequest"
          )
        )
      )
    }
  }
}

//
// ApplyRequestApplyEndArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequestApplyEndArgs {
  chain_tester_id: i32,
}

impl ApplyRequestApplyEndArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequestApplyEndArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyRequestApplyEndArgs.chain_tester_id", &f_1)?;
    let ret = ApplyRequestApplyEndArgs {
      chain_tester_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("apply_end_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("chainTesterId", TType::I32, 1))?;
    o_prot.write_i32(self.chain_tester_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyRequestApplyEndResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequestApplyEndResult {
  result_value: Option<i32>,
}

impl ApplyRequestApplyEndResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequestApplyEndResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyRequestApplyEndResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyRequestApplyEndResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyRequestApplyEnd"
          )
        )
      )
    }
  }
}

//
// Apply service client
//

pub trait TApplySyncClient {
  fn end_apply(&mut self) -> thrift::Result<i32>;
  fn get_active_producers(&mut self) -> thrift::Result<Vec<u8>>;
  fn get_resource_limits(&mut self, account: Uint64) -> thrift::Result<GetResourceLimitsReturn>;
  fn set_resource_limits(&mut self, account: Uint64, ram_bytes: i64, net_weight: i64, cpu_weight: i64) -> thrift::Result<()>;
  fn set_proposed_producers(&mut self, producer_data: Vec<u8>) -> thrift::Result<i64>;
  fn set_proposed_producers_ex(&mut self, producer_data_format: Uint64, producer_data: Vec<u8>) -> thrift::Result<i64>;
  fn is_privileged(&mut self, account: Uint64) -> thrift::Result<bool>;
  fn set_privileged(&mut self, account: Uint64, is_priv: bool) -> thrift::Result<()>;
  fn set_blockchain_parameters_packed(&mut self, data: Vec<u8>) -> thrift::Result<()>;
  fn get_blockchain_parameters_packed(&mut self) -> thrift::Result<Vec<u8>>;
  fn preactivate_feature(&mut self, feature_digest: Vec<u8>) -> thrift::Result<()>;
  fn check_transaction_authorization(&mut self, trx_data: Vec<u8>, pubkeys_data: Vec<u8>, perms_data: Vec<u8>) -> thrift::Result<i32>;
  fn check_permission_authorization(&mut self, account: Uint64, permission: Uint64, pubkeys_data: Vec<u8>, perms_data: Vec<u8>, delay_us: Uint64) -> thrift::Result<i32>;
  fn get_permission_last_used(&mut self, account: Uint64, permission: Uint64) -> thrift::Result<i64>;
  fn get_account_creation_time(&mut self, account: Uint64) -> thrift::Result<i64>;
  fn prints(&mut self, cstr: String) -> thrift::Result<()>;
  fn prints_l(&mut self, cstr: Vec<u8>) -> thrift::Result<()>;
  fn printi(&mut self, n: i64) -> thrift::Result<()>;
  fn printui(&mut self, n: Uint64) -> thrift::Result<()>;
  fn printi128(&mut self, value: Vec<u8>) -> thrift::Result<()>;
  fn printui128(&mut self, value: Vec<u8>) -> thrift::Result<()>;
  fn printsf(&mut self, value: Vec<u8>) -> thrift::Result<()>;
  fn printdf(&mut self, value: Vec<u8>) -> thrift::Result<()>;
  fn printqf(&mut self, value: Vec<u8>) -> thrift::Result<()>;
  fn printn(&mut self, name: Uint64) -> thrift::Result<()>;
  fn printhex(&mut self, data: Vec<u8>) -> thrift::Result<()>;
  fn action_data_size(&mut self) -> thrift::Result<i32>;
  fn read_action_data(&mut self) -> thrift::Result<Vec<u8>>;
  fn require_recipient(&mut self, name: Uint64) -> thrift::Result<()>;
  fn require_auth(&mut self, name: Uint64) -> thrift::Result<()>;
  fn has_auth(&mut self, name: Uint64) -> thrift::Result<bool>;
  fn require_auth2(&mut self, name: Uint64, permission: Uint64) -> thrift::Result<()>;
  fn is_account(&mut self, name: Uint64) -> thrift::Result<bool>;
  fn send_inline(&mut self, serialized_action: Vec<u8>) -> thrift::Result<()>;
  fn send_context_free_inline(&mut self, serialized_data: Vec<u8>) -> thrift::Result<()>;
  fn publication_time(&mut self) -> thrift::Result<Uint64>;
  fn current_receiver(&mut self) -> thrift::Result<Uint64>;
  fn eosio_assert(&mut self, test: bool, msg: Vec<u8>) -> thrift::Result<()>;
  fn eosio_assert_message(&mut self, test: bool, msg: Vec<u8>) -> thrift::Result<()>;
  fn eosio_assert_code(&mut self, test: bool, code: Uint64) -> thrift::Result<()>;
  fn eosio_exit(&mut self, code: i32) -> thrift::Result<()>;
  fn current_time(&mut self) -> thrift::Result<Uint64>;
  fn is_feature_activated(&mut self, feature_digest: Vec<u8>) -> thrift::Result<bool>;
  fn get_sender(&mut self) -> thrift::Result<Uint64>;
  fn assert_sha256(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn assert_sha1(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn assert_sha512(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn assert_ripemd160(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn sha256(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn sha1(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn sha512(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn ripemd160(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn recover_key(&mut self, digest: Vec<u8>, sig: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn assert_recover_key(&mut self, digest: Vec<u8>, sig: Vec<u8>, pub_: Vec<u8>) -> thrift::Result<()>;
  fn send_deferred(&mut self, sender_id: Vec<u8>, payer: Uint64, serialized_transaction: Vec<u8>, replace_existing: i32) -> thrift::Result<()>;
  fn cancel_deferred(&mut self, sender_id: Vec<u8>) -> thrift::Result<i32>;
  fn read_transaction(&mut self) -> thrift::Result<Vec<u8>>;
  fn transaction_size(&mut self) -> thrift::Result<i32>;
  fn tapos_block_num(&mut self) -> thrift::Result<i32>;
  fn tapos_block_prefix(&mut self) -> thrift::Result<i32>;
  fn expiration(&mut self) -> thrift::Result<i64>;
  fn get_action(&mut self, _type: i32, index: i32) -> thrift::Result<Vec<u8>>;
  fn get_context_free_data(&mut self, index: i32) -> thrift::Result<Vec<u8>>;
  fn db_store_i64(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Vec<u8>) -> thrift::Result<i32>;
  fn db_update_i64(&mut self, iterator: i32, payer: Uint64, data: Vec<u8>) -> thrift::Result<()>;
  fn db_remove_i64(&mut self, iterator: i32) -> thrift::Result<()>;
  fn db_get_i64(&mut self, iterator: i32) -> thrift::Result<Vec<u8>>;
  fn db_next_i64(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_previous_i64(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_find_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32>;
  fn db_lowerbound_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32>;
  fn db_upperbound_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32>;
  fn db_end_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn db_idx64_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Uint64) -> thrift::Result<i32>;
  fn db_idx64_update(&mut self, iterator: i32, payer: Uint64, secondary: Uint64) -> thrift::Result<()>;
  fn db_idx64_remove(&mut self, iterator: i32) -> thrift::Result<()>;
  fn db_idx64_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx64_previous(&mut self, iteratory: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx64_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn db_idx64_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64) -> thrift::Result<FindSecondaryReturn>;
  fn db_idx64_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx64_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx64_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn db_idx128_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32>;
  fn db_idx128_update(&mut self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()>;
  fn db_idx128_remove(&mut self, iterator: i32) -> thrift::Result<()>;
  fn db_idx128_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx128_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx128_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn db_idx128_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn db_idx128_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx128_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx128_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn db_idx256_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Vec<u8>) -> thrift::Result<i32>;
  fn db_idx256_update(&mut self, iterator: i32, payer: Uint64, data: Vec<u8>) -> thrift::Result<()>;
  fn db_idx256_remove(&mut self, iterator: i32) -> thrift::Result<()>;
  fn db_idx256_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx256_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx256_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn db_idx256_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn db_idx256_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx256_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx256_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn db_idx_double_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32>;
  fn db_idx_double_update(&mut self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()>;
  fn db_idx_double_remove(&mut self, iterator: i32) -> thrift::Result<()>;
  fn db_idx_double_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx_double_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx_double_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn db_idx_double_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn db_idx_double_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx_double_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx_double_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn db_idx_long_double_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32>;
  fn db_idx_long_double_update(&mut self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()>;
  fn db_idx_long_double_remove(&mut self, iterator: i32) -> thrift::Result<()>;
  fn db_idx_long_double_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx_long_double_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn db_idx_long_double_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn db_idx_long_double_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn db_idx_long_double_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx_long_double_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn db_idx_long_double_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn set_action_return_value(&mut self, data: Vec<u8>) -> thrift::Result<()>;
  fn get_code_hash(&mut self, account: Uint64, struct_version: i64) -> thrift::Result<Vec<u8>>;
  fn get_block_num(&mut self) -> thrift::Result<i64>;
  fn sha3(&mut self, data: Vec<u8>, keccak: i32) -> thrift::Result<Vec<u8>>;
  fn blake2_f(&mut self, rounds: i64, state: Vec<u8>, msg: Vec<u8>, t0_offset: Vec<u8>, t1_offset: Vec<u8>, final_: i32) -> thrift::Result<Vec<u8>>;
  fn k1_recover(&mut self, sig: Vec<u8>, dig: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn alt_bn128_add(&mut self, op1: Vec<u8>, op2: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn alt_bn128_mul(&mut self, g1: Vec<u8>, scalar: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn alt_bn128_pair(&mut self, pairs: Vec<u8>) -> thrift::Result<i32>;
  fn mod_exp(&mut self, base: Vec<u8>, exp: Vec<u8>, mod_: Vec<u8>) -> thrift::Result<Vec<u8>>;
}

pub trait TApplySyncClientMarker {}

pub struct ApplySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ApplySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ApplySyncClient<IP, OP> {
    ApplySyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ApplySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TApplySyncClientMarker for ApplySyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TApplySyncClientMarker> TApplySyncClient for C {
  fn end_apply(&mut self) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("end_apply", TMessageType::Call, self.sequence_number());
        let call_args = ApplyEndApplyArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("end_apply", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyEndApplyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_active_producers(&mut self) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_active_producers", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetActiveProducersArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_active_producers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetActiveProducersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_resource_limits(&mut self, account: Uint64) -> thrift::Result<GetResourceLimitsReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_resource_limits", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetResourceLimitsArgs { account };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_resource_limits", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetResourceLimitsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_resource_limits(&mut self, account: Uint64, ram_bytes: i64, net_weight: i64, cpu_weight: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_resource_limits", TMessageType::Call, self.sequence_number());
        let call_args = ApplySetResourceLimitsArgs { account, ram_bytes, net_weight, cpu_weight };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_resource_limits", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySetResourceLimitsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_proposed_producers(&mut self, producer_data: Vec<u8>) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_proposed_producers", TMessageType::Call, self.sequence_number());
        let call_args = ApplySetProposedProducersArgs { producer_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_proposed_producers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySetProposedProducersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_proposed_producers_ex(&mut self, producer_data_format: Uint64, producer_data: Vec<u8>) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_proposed_producers_ex", TMessageType::Call, self.sequence_number());
        let call_args = ApplySetProposedProducersExArgs { producer_data_format, producer_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_proposed_producers_ex", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySetProposedProducersExResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_privileged(&mut self, account: Uint64) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("is_privileged", TMessageType::Call, self.sequence_number());
        let call_args = ApplyIsPrivilegedArgs { account };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("is_privileged", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyIsPrivilegedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_privileged(&mut self, account: Uint64, is_priv: bool) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_privileged", TMessageType::Call, self.sequence_number());
        let call_args = ApplySetPrivilegedArgs { account, is_priv };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_privileged", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySetPrivilegedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_blockchain_parameters_packed(&mut self, data: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_blockchain_parameters_packed", TMessageType::Call, self.sequence_number());
        let call_args = ApplySetBlockchainParametersPackedArgs { data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_blockchain_parameters_packed", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySetBlockchainParametersPackedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_blockchain_parameters_packed(&mut self) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_blockchain_parameters_packed", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetBlockchainParametersPackedArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_blockchain_parameters_packed", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetBlockchainParametersPackedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn preactivate_feature(&mut self, feature_digest: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("preactivate_feature", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPreactivateFeatureArgs { feature_digest };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("preactivate_feature", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPreactivateFeatureResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_transaction_authorization(&mut self, trx_data: Vec<u8>, pubkeys_data: Vec<u8>, perms_data: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("check_transaction_authorization", TMessageType::Call, self.sequence_number());
        let call_args = ApplyCheckTransactionAuthorizationArgs { trx_data, pubkeys_data, perms_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("check_transaction_authorization", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyCheckTransactionAuthorizationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn check_permission_authorization(&mut self, account: Uint64, permission: Uint64, pubkeys_data: Vec<u8>, perms_data: Vec<u8>, delay_us: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("check_permission_authorization", TMessageType::Call, self.sequence_number());
        let call_args = ApplyCheckPermissionAuthorizationArgs { account, permission, pubkeys_data, perms_data, delay_us };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("check_permission_authorization", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyCheckPermissionAuthorizationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_permission_last_used(&mut self, account: Uint64, permission: Uint64) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_permission_last_used", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetPermissionLastUsedArgs { account, permission };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_permission_last_used", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetPermissionLastUsedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_account_creation_time(&mut self, account: Uint64) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_account_creation_time", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetAccountCreationTimeArgs { account };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_account_creation_time", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetAccountCreationTimeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn prints(&mut self, cstr: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("prints", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintsArgs { cstr };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("prints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn prints_l(&mut self, cstr: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("prints_l", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintsLArgs { cstr };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("prints_l", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintsLResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printi(&mut self, n: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printi", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintiArgs { n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printi", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printui(&mut self, n: Uint64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printui", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintuiArgs { n };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printui", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintuiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printi128(&mut self, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printi128", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrinti128Args { value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printi128", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrinti128Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printui128(&mut self, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printui128", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintui128Args { value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printui128", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintui128Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printsf(&mut self, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printsf", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintsfArgs { value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printsf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintsfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printdf(&mut self, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printdf", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintdfArgs { value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printdf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintdfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printqf(&mut self, value: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printqf", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintqfArgs { value };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printqf", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintqfResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printn(&mut self, name: Uint64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printn", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrintnArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printn", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrintnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn printhex(&mut self, data: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("printhex", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPrinthexArgs { data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("printhex", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPrinthexResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn action_data_size(&mut self) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("action_data_size", TMessageType::Call, self.sequence_number());
        let call_args = ApplyActionDataSizeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("action_data_size", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyActionDataSizeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn read_action_data(&mut self) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("read_action_data", TMessageType::Call, self.sequence_number());
        let call_args = ApplyReadActionDataArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("read_action_data", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyReadActionDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn require_recipient(&mut self, name: Uint64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("require_recipient", TMessageType::Call, self.sequence_number());
        let call_args = ApplyRequireRecipientArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("require_recipient", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyRequireRecipientResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn require_auth(&mut self, name: Uint64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("require_auth", TMessageType::Call, self.sequence_number());
        let call_args = ApplyRequireAuthArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("require_auth", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyRequireAuthResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn has_auth(&mut self, name: Uint64) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("has_auth", TMessageType::Call, self.sequence_number());
        let call_args = ApplyHasAuthArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("has_auth", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyHasAuthResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn require_auth2(&mut self, name: Uint64, permission: Uint64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("require_auth2", TMessageType::Call, self.sequence_number());
        let call_args = ApplyRequireAuth2Args { name, permission };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("require_auth2", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyRequireAuth2Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_account(&mut self, name: Uint64) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("is_account", TMessageType::Call, self.sequence_number());
        let call_args = ApplyIsAccountArgs { name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("is_account", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyIsAccountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_inline(&mut self, serialized_action: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("send_inline", TMessageType::Call, self.sequence_number());
        let call_args = ApplySendInlineArgs { serialized_action };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("send_inline", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySendInlineResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_context_free_inline(&mut self, serialized_data: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("send_context_free_inline", TMessageType::Call, self.sequence_number());
        let call_args = ApplySendContextFreeInlineArgs { serialized_data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("send_context_free_inline", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySendContextFreeInlineResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn publication_time(&mut self) -> thrift::Result<Uint64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("publication_time", TMessageType::Call, self.sequence_number());
        let call_args = ApplyPublicationTimeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("publication_time", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyPublicationTimeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn current_receiver(&mut self) -> thrift::Result<Uint64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("current_receiver", TMessageType::Call, self.sequence_number());
        let call_args = ApplyCurrentReceiverArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("current_receiver", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyCurrentReceiverResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn eosio_assert(&mut self, test: bool, msg: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("eosio_assert", TMessageType::Call, self.sequence_number());
        let call_args = ApplyEosioAssertArgs { test, msg };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("eosio_assert", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyEosioAssertResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn eosio_assert_message(&mut self, test: bool, msg: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("eosio_assert_message", TMessageType::Call, self.sequence_number());
        let call_args = ApplyEosioAssertMessageArgs { test, msg };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("eosio_assert_message", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyEosioAssertMessageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn eosio_assert_code(&mut self, test: bool, code: Uint64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("eosio_assert_code", TMessageType::Call, self.sequence_number());
        let call_args = ApplyEosioAssertCodeArgs { test, code };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("eosio_assert_code", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyEosioAssertCodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn eosio_exit(&mut self, code: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("eosio_exit", TMessageType::Call, self.sequence_number());
        let call_args = ApplyEosioExitArgs { code };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("eosio_exit", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyEosioExitResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn current_time(&mut self) -> thrift::Result<Uint64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("current_time", TMessageType::Call, self.sequence_number());
        let call_args = ApplyCurrentTimeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("current_time", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyCurrentTimeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn is_feature_activated(&mut self, feature_digest: Vec<u8>) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("is_feature_activated", TMessageType::Call, self.sequence_number());
        let call_args = ApplyIsFeatureActivatedArgs { feature_digest };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("is_feature_activated", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyIsFeatureActivatedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_sender(&mut self) -> thrift::Result<Uint64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_sender", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetSenderArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_sender", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetSenderResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn assert_sha256(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("assert_sha256", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAssertSha256Args { data, hash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("assert_sha256", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAssertSha256Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn assert_sha1(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("assert_sha1", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAssertSha1Args { data, hash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("assert_sha1", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAssertSha1Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn assert_sha512(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("assert_sha512", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAssertSha512Args { data, hash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("assert_sha512", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAssertSha512Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn assert_ripemd160(&mut self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("assert_ripemd160", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAssertRipemd160Args { data, hash };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("assert_ripemd160", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAssertRipemd160Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sha256(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sha256", TMessageType::Call, self.sequence_number());
        let call_args = ApplySha256Args { data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sha256", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySha256Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sha1(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sha1", TMessageType::Call, self.sequence_number());
        let call_args = ApplySha1Args { data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sha1", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySha1Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sha512(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sha512", TMessageType::Call, self.sequence_number());
        let call_args = ApplySha512Args { data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sha512", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySha512Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn ripemd160(&mut self, data: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ripemd160", TMessageType::Call, self.sequence_number());
        let call_args = ApplyRipemd160Args { data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ripemd160", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyRipemd160Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn recover_key(&mut self, digest: Vec<u8>, sig: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("recover_key", TMessageType::Call, self.sequence_number());
        let call_args = ApplyRecoverKeyArgs { digest, sig };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("recover_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyRecoverKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn assert_recover_key(&mut self, digest: Vec<u8>, sig: Vec<u8>, pub_: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("assert_recover_key", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAssertRecoverKeyArgs { digest, sig, pub_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("assert_recover_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAssertRecoverKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn send_deferred(&mut self, sender_id: Vec<u8>, payer: Uint64, serialized_transaction: Vec<u8>, replace_existing: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("send_deferred", TMessageType::Call, self.sequence_number());
        let call_args = ApplySendDeferredArgs { sender_id, payer, serialized_transaction, replace_existing };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("send_deferred", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySendDeferredResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cancel_deferred(&mut self, sender_id: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("cancel_deferred", TMessageType::Call, self.sequence_number());
        let call_args = ApplyCancelDeferredArgs { sender_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("cancel_deferred", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyCancelDeferredResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn read_transaction(&mut self) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("read_transaction", TMessageType::Call, self.sequence_number());
        let call_args = ApplyReadTransactionArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("read_transaction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyReadTransactionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn transaction_size(&mut self) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("transaction_size", TMessageType::Call, self.sequence_number());
        let call_args = ApplyTransactionSizeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("transaction_size", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyTransactionSizeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tapos_block_num(&mut self) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("tapos_block_num", TMessageType::Call, self.sequence_number());
        let call_args = ApplyTaposBlockNumArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("tapos_block_num", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyTaposBlockNumResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tapos_block_prefix(&mut self) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("tapos_block_prefix", TMessageType::Call, self.sequence_number());
        let call_args = ApplyTaposBlockPrefixArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("tapos_block_prefix", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyTaposBlockPrefixResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn expiration(&mut self) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("expiration", TMessageType::Call, self.sequence_number());
        let call_args = ApplyExpirationArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("expiration", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyExpirationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_action(&mut self, _type: i32, index: i32) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_action", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetActionArgs { _type, index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_action", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetActionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_context_free_data(&mut self, index: i32) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_context_free_data", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetContextFreeDataArgs { index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_context_free_data", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetContextFreeDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_store_i64(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_store_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbStoreI64Args { scope, table, payer, id, data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_store_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbStoreI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_update_i64(&mut self, iterator: i32, payer: Uint64, data: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_update_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbUpdateI64Args { iterator, payer, data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_update_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbUpdateI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_remove_i64(&mut self, iterator: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_remove_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbRemoveI64Args { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_remove_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbRemoveI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_get_i64(&mut self, iterator: i32) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_get_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbGetI64Args { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_get_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbGetI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_next_i64(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_next_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbNextI64Args { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_next_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbNextI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_previous_i64(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_previous_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbPreviousI64Args { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_previous_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbPreviousI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_find_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_find_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbFindI64Args { code, scope, table, id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_find_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbFindI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_lowerbound_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_lowerbound_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbLowerboundI64Args { code, scope, table, id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_lowerbound_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbLowerboundI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_upperbound_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_upperbound_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbUpperboundI64Args { code, scope, table, id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_upperbound_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbUpperboundI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_end_i64(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_end_i64", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbEndI64Args { code, scope, table };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_end_i64", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbEndI64Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_store", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64StoreArgs { scope, table, payer, id, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_store", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64StoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_update(&mut self, iterator: i32, payer: Uint64, secondary: Uint64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_update", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64UpdateArgs { iterator, payer, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64UpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_remove(&mut self, iterator: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_remove", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64RemoveArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_remove", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64RemoveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_next", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64NextArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_next", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64NextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_previous(&mut self, iteratory: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_previous", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64PreviousArgs { iteratory };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_previous", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64PreviousResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_find_primary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64FindPrimaryArgs { code, scope, table, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_find_primary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64FindPrimaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64) -> thrift::Result<FindSecondaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_find_secondary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64FindSecondaryArgs { code, scope, table, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_find_secondary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64FindSecondaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_lowerbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64LowerboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_lowerbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64LowerboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_upperbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64UpperboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_upperbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64UpperboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx64_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx64_end", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx64EndArgs { code, scope, table };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx64_end", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx64EndResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_store", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128StoreArgs { scope, table, payer, id, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_store", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128StoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_update(&mut self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_update", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128UpdateArgs { iterator, payer, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128UpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_remove(&mut self, iterator: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_remove", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128RemoveArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_remove", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128RemoveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_next", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128NextArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_next", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128NextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_previous", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128PreviousArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_previous", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128PreviousResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_find_primary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128FindPrimaryArgs { code, scope, table, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_find_primary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128FindPrimaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_find_secondary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128FindSecondaryArgs { code, scope, table, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_find_secondary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128FindSecondaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_lowerbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128LowerboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_lowerbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128LowerboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_upperbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128UpperboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_upperbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128UpperboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx128_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx128_end", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx128EndArgs { code, scope, table };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx128_end", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx128EndResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_store", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256StoreArgs { scope, table, payer, id, data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_store", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256StoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_update(&mut self, iterator: i32, payer: Uint64, data: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_update", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256UpdateArgs { iterator, payer, data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256UpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_remove(&mut self, iterator: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_remove", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256RemoveArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_remove", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256RemoveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_next", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256NextArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_next", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256NextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_previous", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256PreviousArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_previous", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256PreviousResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_find_primary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256FindPrimaryArgs { code, scope, table, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_find_primary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256FindPrimaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>) -> thrift::Result<FindSecondaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_find_secondary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256FindSecondaryArgs { code, scope, table, data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_find_secondary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256FindSecondaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_lowerbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256LowerboundArgs { code, scope, table, data, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_lowerbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256LowerboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_upperbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256UpperboundArgs { code, scope, table, data, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_upperbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256UpperboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx256_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx256_end", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdx256EndArgs { code, scope, table };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx256_end", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdx256EndResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_store", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleStoreArgs { scope, table, payer, id, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_store", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleStoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_update(&mut self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_update", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleUpdateArgs { iterator, payer, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleUpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_remove(&mut self, iterator: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_remove", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleRemoveArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_remove", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleRemoveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_next", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleNextArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_next", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleNextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_previous", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoublePreviousArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_previous", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoublePreviousResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_find_primary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleFindPrimaryArgs { code, scope, table, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_find_primary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleFindPrimaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_find_secondary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleFindSecondaryArgs { code, scope, table, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_find_secondary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleFindSecondaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_lowerbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleLowerboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_lowerbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleLowerboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_upperbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleUpperboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_upperbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleUpperboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_double_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_double_end", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxDoubleEndArgs { code, scope, table };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_double_end", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxDoubleEndResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_store(&mut self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_store", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleStoreArgs { scope, table, payer, id, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_store", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleStoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_update(&mut self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_update", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleUpdateArgs { iterator, payer, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleUpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_remove(&mut self, iterator: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_remove", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleRemoveArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_remove", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleRemoveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_next(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_next", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleNextArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_next", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleNextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_previous(&mut self, iterator: i32) -> thrift::Result<NextPreviousReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_previous", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoublePreviousArgs { iterator };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_previous", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoublePreviousResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_find_primary(&mut self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_find_primary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleFindPrimaryArgs { code, scope, table, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_find_primary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleFindPrimaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_find_secondary(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_find_secondary", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleFindSecondaryArgs { code, scope, table, secondary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_find_secondary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleFindSecondaryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_lowerbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_lowerbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleLowerboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_lowerbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleLowerboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_upperbound(&mut self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_upperbound", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleUpperboundArgs { code, scope, table, secondary, primary };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_upperbound", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleUpperboundResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn db_idx_long_double_end(&mut self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("db_idx_long_double_end", TMessageType::Call, self.sequence_number());
        let call_args = ApplyDbIdxLongDoubleEndArgs { code, scope, table };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("db_idx_long_double_end", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyDbIdxLongDoubleEndResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_action_return_value(&mut self, data: Vec<u8>) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("set_action_return_value", TMessageType::Call, self.sequence_number());
        let call_args = ApplySetActionReturnValueArgs { data };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("set_action_return_value", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySetActionReturnValueResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_code_hash(&mut self, account: Uint64, struct_version: i64) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_code_hash", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetCodeHashArgs { account, struct_version };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_code_hash", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetCodeHashResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_block_num(&mut self) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("get_block_num", TMessageType::Call, self.sequence_number());
        let call_args = ApplyGetBlockNumArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("get_block_num", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyGetBlockNumResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sha3(&mut self, data: Vec<u8>, keccak: i32) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sha3", TMessageType::Call, self.sequence_number());
        let call_args = ApplySha3Args { data, keccak };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sha3", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplySha3Result::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn blake2_f(&mut self, rounds: i64, state: Vec<u8>, msg: Vec<u8>, t0_offset: Vec<u8>, t1_offset: Vec<u8>, final_: i32) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("blake2_f", TMessageType::Call, self.sequence_number());
        let call_args = ApplyBlake2FArgs { rounds, state, msg, t0_offset, t1_offset, final_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("blake2_f", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyBlake2FResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn k1_recover(&mut self, sig: Vec<u8>, dig: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("k1_recover", TMessageType::Call, self.sequence_number());
        let call_args = ApplyK1RecoverArgs { sig, dig };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("k1_recover", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyK1RecoverResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alt_bn128_add(&mut self, op1: Vec<u8>, op2: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alt_bn128_add", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAltBn128AddArgs { op1, op2 };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alt_bn128_add", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAltBn128AddResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alt_bn128_mul(&mut self, g1: Vec<u8>, scalar: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alt_bn128_mul", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAltBn128MulArgs { g1, scalar };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alt_bn128_mul", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAltBn128MulResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn alt_bn128_pair(&mut self, pairs: Vec<u8>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("alt_bn128_pair", TMessageType::Call, self.sequence_number());
        let call_args = ApplyAltBn128PairArgs { pairs };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("alt_bn128_pair", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyAltBn128PairResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn mod_exp(&mut self, base: Vec<u8>, exp: Vec<u8>, mod_: Vec<u8>) -> thrift::Result<Vec<u8>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("mod_exp", TMessageType::Call, self.sequence_number());
        let call_args = ApplyModExpArgs { base, exp, mod_ };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("mod_exp", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ApplyModExpResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// Apply service processor
//

pub trait ApplySyncHandler {
  fn handle_end_apply(&self) -> thrift::Result<i32>;
  fn handle_get_active_producers(&self) -> thrift::Result<Vec<u8>>;
  fn handle_get_resource_limits(&self, account: Uint64) -> thrift::Result<GetResourceLimitsReturn>;
  fn handle_set_resource_limits(&self, account: Uint64, ram_bytes: i64, net_weight: i64, cpu_weight: i64) -> thrift::Result<()>;
  fn handle_set_proposed_producers(&self, producer_data: Vec<u8>) -> thrift::Result<i64>;
  fn handle_set_proposed_producers_ex(&self, producer_data_format: Uint64, producer_data: Vec<u8>) -> thrift::Result<i64>;
  fn handle_is_privileged(&self, account: Uint64) -> thrift::Result<bool>;
  fn handle_set_privileged(&self, account: Uint64, is_priv: bool) -> thrift::Result<()>;
  fn handle_set_blockchain_parameters_packed(&self, data: Vec<u8>) -> thrift::Result<()>;
  fn handle_get_blockchain_parameters_packed(&self) -> thrift::Result<Vec<u8>>;
  fn handle_preactivate_feature(&self, feature_digest: Vec<u8>) -> thrift::Result<()>;
  fn handle_check_transaction_authorization(&self, trx_data: Vec<u8>, pubkeys_data: Vec<u8>, perms_data: Vec<u8>) -> thrift::Result<i32>;
  fn handle_check_permission_authorization(&self, account: Uint64, permission: Uint64, pubkeys_data: Vec<u8>, perms_data: Vec<u8>, delay_us: Uint64) -> thrift::Result<i32>;
  fn handle_get_permission_last_used(&self, account: Uint64, permission: Uint64) -> thrift::Result<i64>;
  fn handle_get_account_creation_time(&self, account: Uint64) -> thrift::Result<i64>;
  fn handle_prints(&self, cstr: String) -> thrift::Result<()>;
  fn handle_prints_l(&self, cstr: Vec<u8>) -> thrift::Result<()>;
  fn handle_printi(&self, n: i64) -> thrift::Result<()>;
  fn handle_printui(&self, n: Uint64) -> thrift::Result<()>;
  fn handle_printi128(&self, value: Vec<u8>) -> thrift::Result<()>;
  fn handle_printui128(&self, value: Vec<u8>) -> thrift::Result<()>;
  fn handle_printsf(&self, value: Vec<u8>) -> thrift::Result<()>;
  fn handle_printdf(&self, value: Vec<u8>) -> thrift::Result<()>;
  fn handle_printqf(&self, value: Vec<u8>) -> thrift::Result<()>;
  fn handle_printn(&self, name: Uint64) -> thrift::Result<()>;
  fn handle_printhex(&self, data: Vec<u8>) -> thrift::Result<()>;
  fn handle_action_data_size(&self) -> thrift::Result<i32>;
  fn handle_read_action_data(&self) -> thrift::Result<Vec<u8>>;
  fn handle_require_recipient(&self, name: Uint64) -> thrift::Result<()>;
  fn handle_require_auth(&self, name: Uint64) -> thrift::Result<()>;
  fn handle_has_auth(&self, name: Uint64) -> thrift::Result<bool>;
  fn handle_require_auth2(&self, name: Uint64, permission: Uint64) -> thrift::Result<()>;
  fn handle_is_account(&self, name: Uint64) -> thrift::Result<bool>;
  fn handle_send_inline(&self, serialized_action: Vec<u8>) -> thrift::Result<()>;
  fn handle_send_context_free_inline(&self, serialized_data: Vec<u8>) -> thrift::Result<()>;
  fn handle_publication_time(&self) -> thrift::Result<Uint64>;
  fn handle_current_receiver(&self) -> thrift::Result<Uint64>;
  fn handle_eosio_assert(&self, test: bool, msg: Vec<u8>) -> thrift::Result<()>;
  fn handle_eosio_assert_message(&self, test: bool, msg: Vec<u8>) -> thrift::Result<()>;
  fn handle_eosio_assert_code(&self, test: bool, code: Uint64) -> thrift::Result<()>;
  fn handle_eosio_exit(&self, code: i32) -> thrift::Result<()>;
  fn handle_current_time(&self) -> thrift::Result<Uint64>;
  fn handle_is_feature_activated(&self, feature_digest: Vec<u8>) -> thrift::Result<bool>;
  fn handle_get_sender(&self) -> thrift::Result<Uint64>;
  fn handle_assert_sha256(&self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn handle_assert_sha1(&self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn handle_assert_sha512(&self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn handle_assert_ripemd160(&self, data: Vec<u8>, hash: Vec<u8>) -> thrift::Result<()>;
  fn handle_sha256(&self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_sha1(&self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_sha512(&self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_ripemd160(&self, data: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_recover_key(&self, digest: Vec<u8>, sig: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_assert_recover_key(&self, digest: Vec<u8>, sig: Vec<u8>, pub_: Vec<u8>) -> thrift::Result<()>;
  fn handle_send_deferred(&self, sender_id: Vec<u8>, payer: Uint64, serialized_transaction: Vec<u8>, replace_existing: i32) -> thrift::Result<()>;
  fn handle_cancel_deferred(&self, sender_id: Vec<u8>) -> thrift::Result<i32>;
  fn handle_read_transaction(&self) -> thrift::Result<Vec<u8>>;
  fn handle_transaction_size(&self) -> thrift::Result<i32>;
  fn handle_tapos_block_num(&self) -> thrift::Result<i32>;
  fn handle_tapos_block_prefix(&self) -> thrift::Result<i32>;
  fn handle_expiration(&self) -> thrift::Result<i64>;
  fn handle_get_action(&self, _type: i32, index: i32) -> thrift::Result<Vec<u8>>;
  fn handle_get_context_free_data(&self, index: i32) -> thrift::Result<Vec<u8>>;
  fn handle_db_store_i64(&self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Vec<u8>) -> thrift::Result<i32>;
  fn handle_db_update_i64(&self, iterator: i32, payer: Uint64, data: Vec<u8>) -> thrift::Result<()>;
  fn handle_db_remove_i64(&self, iterator: i32) -> thrift::Result<()>;
  fn handle_db_get_i64(&self, iterator: i32) -> thrift::Result<Vec<u8>>;
  fn handle_db_next_i64(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_previous_i64(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_find_i64(&self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32>;
  fn handle_db_lowerbound_i64(&self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32>;
  fn handle_db_upperbound_i64(&self, code: Uint64, scope: Uint64, table: Uint64, id: Uint64) -> thrift::Result<i32>;
  fn handle_db_end_i64(&self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn handle_db_idx64_store(&self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Uint64) -> thrift::Result<i32>;
  fn handle_db_idx64_update(&self, iterator: i32, payer: Uint64, secondary: Uint64) -> thrift::Result<()>;
  fn handle_db_idx64_remove(&self, iterator: i32) -> thrift::Result<()>;
  fn handle_db_idx64_next(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx64_previous(&self, iteratory: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx64_find_primary(&self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn handle_db_idx64_find_secondary(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64) -> thrift::Result<FindSecondaryReturn>;
  fn handle_db_idx64_lowerbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx64_upperbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Uint64, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx64_end(&self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn handle_db_idx128_store(&self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32>;
  fn handle_db_idx128_update(&self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()>;
  fn handle_db_idx128_remove(&self, iterator: i32) -> thrift::Result<()>;
  fn handle_db_idx128_next(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx128_previous(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx128_find_primary(&self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn handle_db_idx128_find_secondary(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn handle_db_idx128_lowerbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx128_upperbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx128_end(&self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn handle_db_idx256_store(&self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, data: Vec<u8>) -> thrift::Result<i32>;
  fn handle_db_idx256_update(&self, iterator: i32, payer: Uint64, data: Vec<u8>) -> thrift::Result<()>;
  fn handle_db_idx256_remove(&self, iterator: i32) -> thrift::Result<()>;
  fn handle_db_idx256_next(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx256_previous(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx256_find_primary(&self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn handle_db_idx256_find_secondary(&self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn handle_db_idx256_lowerbound(&self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx256_upperbound(&self, code: Uint64, scope: Uint64, table: Uint64, data: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx256_end(&self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn handle_db_idx_double_store(&self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32>;
  fn handle_db_idx_double_update(&self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()>;
  fn handle_db_idx_double_remove(&self, iterator: i32) -> thrift::Result<()>;
  fn handle_db_idx_double_next(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx_double_previous(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx_double_find_primary(&self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn handle_db_idx_double_find_secondary(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn handle_db_idx_double_lowerbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx_double_upperbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx_double_end(&self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn handle_db_idx_long_double_store(&self, scope: Uint64, table: Uint64, payer: Uint64, id: Uint64, secondary: Vec<u8>) -> thrift::Result<i32>;
  fn handle_db_idx_long_double_update(&self, iterator: i32, payer: Uint64, secondary: Vec<u8>) -> thrift::Result<()>;
  fn handle_db_idx_long_double_remove(&self, iterator: i32) -> thrift::Result<()>;
  fn handle_db_idx_long_double_next(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx_long_double_previous(&self, iterator: i32) -> thrift::Result<NextPreviousReturn>;
  fn handle_db_idx_long_double_find_primary(&self, code: Uint64, scope: Uint64, table: Uint64, primary: Uint64) -> thrift::Result<FindPrimaryReturn>;
  fn handle_db_idx_long_double_find_secondary(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>) -> thrift::Result<FindSecondaryReturn>;
  fn handle_db_idx_long_double_lowerbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx_long_double_upperbound(&self, code: Uint64, scope: Uint64, table: Uint64, secondary: Vec<u8>, primary: Uint64) -> thrift::Result<LowerBoundUpperBoundReturn>;
  fn handle_db_idx_long_double_end(&self, code: Uint64, scope: Uint64, table: Uint64) -> thrift::Result<i32>;
  fn handle_set_action_return_value(&self, data: Vec<u8>) -> thrift::Result<()>;
  fn handle_get_code_hash(&self, account: Uint64, struct_version: i64) -> thrift::Result<Vec<u8>>;
  fn handle_get_block_num(&self) -> thrift::Result<i64>;
  fn handle_sha3(&self, data: Vec<u8>, keccak: i32) -> thrift::Result<Vec<u8>>;
  fn handle_blake2_f(&self, rounds: i64, state: Vec<u8>, msg: Vec<u8>, t0_offset: Vec<u8>, t1_offset: Vec<u8>, final_: i32) -> thrift::Result<Vec<u8>>;
  fn handle_k1_recover(&self, sig: Vec<u8>, dig: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_alt_bn128_add(&self, op1: Vec<u8>, op2: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_alt_bn128_mul(&self, g1: Vec<u8>, scalar: Vec<u8>) -> thrift::Result<Vec<u8>>;
  fn handle_alt_bn128_pair(&self, pairs: Vec<u8>) -> thrift::Result<i32>;
  fn handle_mod_exp(&self, base: Vec<u8>, exp: Vec<u8>, mod_: Vec<u8>) -> thrift::Result<Vec<u8>>;
}

pub struct ApplySyncProcessor<H: ApplySyncHandler> {
  handler: H,
}

impl <H: ApplySyncHandler> ApplySyncProcessor<H> {
  pub fn new(handler: H) -> ApplySyncProcessor<H> {
    ApplySyncProcessor {
      handler,
    }
  }
  fn process_end_apply(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_end_apply(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_active_producers(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_active_producers(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_resource_limits(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_resource_limits(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_resource_limits(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_set_resource_limits(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_proposed_producers(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_set_proposed_producers(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_proposed_producers_ex(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_set_proposed_producers_ex(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_privileged(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_is_privileged(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_privileged(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_set_privileged(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_blockchain_parameters_packed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_set_blockchain_parameters_packed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_blockchain_parameters_packed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_blockchain_parameters_packed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_preactivate_feature(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_preactivate_feature(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_transaction_authorization(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_check_transaction_authorization(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_check_permission_authorization(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_check_permission_authorization(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_permission_last_used(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_permission_last_used(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_account_creation_time(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_account_creation_time(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_prints(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_prints(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_prints_l(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_prints_l(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printi(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printi(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printui(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printui(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printi128(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printi128(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printui128(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printui128(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printsf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printsf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printdf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printdf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printqf(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printqf(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printn(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printn(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_printhex(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_printhex(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_action_data_size(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_action_data_size(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_read_action_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_read_action_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_require_recipient(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_require_recipient(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_require_auth(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_require_auth(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_has_auth(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_has_auth(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_require_auth2(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_require_auth2(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_account(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_is_account(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_inline(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_send_inline(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_context_free_inline(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_send_context_free_inline(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_publication_time(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_publication_time(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_current_receiver(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_current_receiver(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_eosio_assert(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_eosio_assert(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_eosio_assert_message(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_eosio_assert_message(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_eosio_assert_code(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_eosio_assert_code(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_eosio_exit(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_eosio_exit(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_current_time(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_current_time(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_is_feature_activated(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_is_feature_activated(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_sender(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_sender(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_assert_sha256(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_assert_sha256(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_assert_sha1(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_assert_sha1(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_assert_sha512(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_assert_sha512(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_assert_ripemd160(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_assert_ripemd160(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sha256(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_sha256(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sha1(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_sha1(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sha512(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_sha512(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_ripemd160(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_ripemd160(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_recover_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_recover_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_assert_recover_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_assert_recover_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_send_deferred(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_send_deferred(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cancel_deferred(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_cancel_deferred(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_read_transaction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_read_transaction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_transaction_size(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_transaction_size(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tapos_block_num(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_tapos_block_num(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tapos_block_prefix(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_tapos_block_prefix(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_expiration(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_expiration(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_action(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_action(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_context_free_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_context_free_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_store_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_store_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_update_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_update_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_remove_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_remove_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_get_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_get_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_next_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_next_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_previous_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_previous_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_find_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_find_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_lowerbound_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_lowerbound_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_upperbound_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_upperbound_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_end_i64(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_end_i64(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_store(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_store(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_remove(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_remove(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_next(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_next(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_previous(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_previous(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_find_primary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_find_primary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_find_secondary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_find_secondary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_lowerbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_lowerbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_upperbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_upperbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx64_end(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx64_end(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_store(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_store(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_remove(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_remove(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_next(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_next(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_previous(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_previous(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_find_primary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_find_primary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_find_secondary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_find_secondary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_lowerbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_lowerbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_upperbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_upperbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx128_end(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx128_end(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_store(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_store(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_remove(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_remove(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_next(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_next(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_previous(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_previous(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_find_primary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_find_primary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_find_secondary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_find_secondary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_lowerbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_lowerbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_upperbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_upperbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx256_end(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx256_end(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_store(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_store(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_remove(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_remove(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_next(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_next(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_previous(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_previous(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_find_primary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_find_primary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_find_secondary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_find_secondary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_lowerbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_lowerbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_upperbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_upperbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_double_end(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_double_end(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_store(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_store(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_remove(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_remove(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_next(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_next(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_previous(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_previous(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_find_primary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_find_primary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_find_secondary(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_find_secondary(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_lowerbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_lowerbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_upperbound(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_upperbound(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_db_idx_long_double_end(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_db_idx_long_double_end(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_action_return_value(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_set_action_return_value(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_code_hash(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_code_hash(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_block_num(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_get_block_num(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sha3(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_sha3(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_blake2_f(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_blake2_f(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_k1_recover(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_k1_recover(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alt_bn128_add(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_alt_bn128_add(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alt_bn128_mul(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_alt_bn128_mul(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_alt_bn128_pair(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_alt_bn128_pair(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_mod_exp(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TApplyProcessFunctions::process_mod_exp(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TApplyProcessFunctions;

impl TApplyProcessFunctions {
  pub fn process_end_apply<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyEndApplyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_end_apply() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("end_apply", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyEndApplyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("end_apply", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("end_apply", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_active_producers<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyGetActiveProducersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_active_producers() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_active_producers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetActiveProducersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_active_producers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_active_producers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_resource_limits<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyGetResourceLimitsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_resource_limits(args.account) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_resource_limits", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetResourceLimitsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_resource_limits", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_resource_limits", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_resource_limits<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySetResourceLimitsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_resource_limits(args.account, args.ram_bytes, args.net_weight, args.cpu_weight) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_resource_limits", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySetResourceLimitsResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_resource_limits", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_resource_limits", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_proposed_producers<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySetProposedProducersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_proposed_producers(args.producer_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_proposed_producers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySetProposedProducersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_proposed_producers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_proposed_producers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_proposed_producers_ex<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySetProposedProducersExArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_proposed_producers_ex(args.producer_data_format, args.producer_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("set_proposed_producers_ex", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySetProposedProducersExResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_proposed_producers_ex", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_proposed_producers_ex", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_privileged<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyIsPrivilegedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_privileged(args.account) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("is_privileged", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyIsPrivilegedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("is_privileged", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("is_privileged", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_privileged<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySetPrivilegedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_privileged(args.account, args.is_priv) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_privileged", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySetPrivilegedResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_privileged", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_privileged", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_blockchain_parameters_packed<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySetBlockchainParametersPackedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_blockchain_parameters_packed(args.data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_blockchain_parameters_packed", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySetBlockchainParametersPackedResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_blockchain_parameters_packed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_blockchain_parameters_packed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_blockchain_parameters_packed<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyGetBlockchainParametersPackedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_blockchain_parameters_packed() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_blockchain_parameters_packed", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetBlockchainParametersPackedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_blockchain_parameters_packed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_blockchain_parameters_packed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_preactivate_feature<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPreactivateFeatureArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_preactivate_feature(args.feature_digest) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("preactivate_feature", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPreactivateFeatureResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("preactivate_feature", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("preactivate_feature", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_transaction_authorization<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyCheckTransactionAuthorizationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_transaction_authorization(args.trx_data, args.pubkeys_data, args.perms_data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("check_transaction_authorization", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyCheckTransactionAuthorizationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("check_transaction_authorization", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("check_transaction_authorization", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_check_permission_authorization<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyCheckPermissionAuthorizationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_check_permission_authorization(args.account, args.permission, args.pubkeys_data, args.perms_data, args.delay_us) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("check_permission_authorization", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyCheckPermissionAuthorizationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("check_permission_authorization", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("check_permission_authorization", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_permission_last_used<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyGetPermissionLastUsedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_permission_last_used(args.account, args.permission) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_permission_last_used", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetPermissionLastUsedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_permission_last_used", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_permission_last_used", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_account_creation_time<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyGetAccountCreationTimeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_account_creation_time(args.account) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_account_creation_time", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetAccountCreationTimeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_account_creation_time", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_account_creation_time", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_prints<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_prints(args.cstr) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("prints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintsResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("prints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("prints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_prints_l<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintsLArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_prints_l(args.cstr) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("prints_l", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintsLResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("prints_l", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("prints_l", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printi<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_printi(args.n) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printi", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintiResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printui<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintuiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_printui(args.n) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printui", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintuiResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printui", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printui", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printi128<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrinti128Args::read_from_in_protocol(i_prot)?;
    match handler.handle_printi128(args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printi128", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrinti128Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printi128", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printi128", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printui128<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintui128Args::read_from_in_protocol(i_prot)?;
    match handler.handle_printui128(args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printui128", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintui128Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printui128", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printui128", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printsf<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintsfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_printsf(args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printsf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintsfResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printsf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printsf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printdf<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintdfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_printdf(args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printdf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintdfResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printdf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printqf<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintqfArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_printqf(args.value) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printqf", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintqfResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printqf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printqf", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printn<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrintnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_printn(args.name) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printn", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrintnResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_printhex<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyPrinthexArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_printhex(args.data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("printhex", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPrinthexResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("printhex", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("printhex", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_action_data_size<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyActionDataSizeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_action_data_size() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("action_data_size", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyActionDataSizeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("action_data_size", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("action_data_size", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_read_action_data<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyReadActionDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_read_action_data() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("read_action_data", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyReadActionDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("read_action_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("read_action_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_require_recipient<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyRequireRecipientArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_require_recipient(args.name) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("require_recipient", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyRequireRecipientResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("require_recipient", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("require_recipient", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_require_auth<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyRequireAuthArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_require_auth(args.name) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("require_auth", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyRequireAuthResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("require_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("require_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_has_auth<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyHasAuthArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_has_auth(args.name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("has_auth", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyHasAuthResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("has_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("has_auth", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_require_auth2<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyRequireAuth2Args::read_from_in_protocol(i_prot)?;
    match handler.handle_require_auth2(args.name, args.permission) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("require_auth2", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyRequireAuth2Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("require_auth2", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("require_auth2", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_account<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyIsAccountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_account(args.name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("is_account", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyIsAccountResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("is_account", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("is_account", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_inline<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySendInlineArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_inline(args.serialized_action) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("send_inline", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySendInlineResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("send_inline", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("send_inline", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_context_free_inline<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySendContextFreeInlineArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_context_free_inline(args.serialized_data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("send_context_free_inline", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySendContextFreeInlineResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("send_context_free_inline", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("send_context_free_inline", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_publication_time<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyPublicationTimeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_publication_time() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("publication_time", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyPublicationTimeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("publication_time", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("publication_time", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_current_receiver<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyCurrentReceiverArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_current_receiver() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("current_receiver", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyCurrentReceiverResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("current_receiver", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("current_receiver", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_eosio_assert<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyEosioAssertArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_eosio_assert(args.test, args.msg) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("eosio_assert", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyEosioAssertResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("eosio_assert", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("eosio_assert", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_eosio_assert_message<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyEosioAssertMessageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_eosio_assert_message(args.test, args.msg) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("eosio_assert_message", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyEosioAssertMessageResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("eosio_assert_message", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("eosio_assert_message", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_eosio_assert_code<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyEosioAssertCodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_eosio_assert_code(args.test, args.code) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("eosio_assert_code", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyEosioAssertCodeResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("eosio_assert_code", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("eosio_assert_code", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_eosio_exit<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyEosioExitArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_eosio_exit(args.code) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("eosio_exit", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyEosioExitResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("eosio_exit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("eosio_exit", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_current_time<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyCurrentTimeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_current_time() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("current_time", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyCurrentTimeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("current_time", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("current_time", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_is_feature_activated<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyIsFeatureActivatedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_is_feature_activated(args.feature_digest) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("is_feature_activated", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyIsFeatureActivatedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("is_feature_activated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("is_feature_activated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_sender<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyGetSenderArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_sender() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_sender", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetSenderResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_sender", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_sender", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_assert_sha256<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAssertSha256Args::read_from_in_protocol(i_prot)?;
    match handler.handle_assert_sha256(args.data, args.hash) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("assert_sha256", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAssertSha256Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("assert_sha256", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("assert_sha256", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_assert_sha1<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAssertSha1Args::read_from_in_protocol(i_prot)?;
    match handler.handle_assert_sha1(args.data, args.hash) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("assert_sha1", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAssertSha1Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("assert_sha1", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("assert_sha1", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_assert_sha512<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAssertSha512Args::read_from_in_protocol(i_prot)?;
    match handler.handle_assert_sha512(args.data, args.hash) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("assert_sha512", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAssertSha512Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("assert_sha512", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("assert_sha512", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_assert_ripemd160<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAssertRipemd160Args::read_from_in_protocol(i_prot)?;
    match handler.handle_assert_ripemd160(args.data, args.hash) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("assert_ripemd160", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAssertRipemd160Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("assert_ripemd160", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("assert_ripemd160", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sha256<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySha256Args::read_from_in_protocol(i_prot)?;
    match handler.handle_sha256(args.data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sha256", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySha256Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sha256", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sha256", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sha1<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySha1Args::read_from_in_protocol(i_prot)?;
    match handler.handle_sha1(args.data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sha1", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySha1Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sha1", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sha1", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sha512<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySha512Args::read_from_in_protocol(i_prot)?;
    match handler.handle_sha512(args.data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sha512", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySha512Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sha512", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sha512", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_ripemd160<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyRipemd160Args::read_from_in_protocol(i_prot)?;
    match handler.handle_ripemd160(args.data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ripemd160", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyRipemd160Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ripemd160", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ripemd160", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_recover_key<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyRecoverKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_recover_key(args.digest, args.sig) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("recover_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyRecoverKeyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("recover_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("recover_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_assert_recover_key<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAssertRecoverKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_assert_recover_key(args.digest, args.sig, args.pub_) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("assert_recover_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAssertRecoverKeyResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("assert_recover_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("assert_recover_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_send_deferred<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySendDeferredArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_send_deferred(args.sender_id, args.payer, args.serialized_transaction, args.replace_existing) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("send_deferred", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySendDeferredResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("send_deferred", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("send_deferred", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cancel_deferred<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyCancelDeferredArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cancel_deferred(args.sender_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("cancel_deferred", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyCancelDeferredResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("cancel_deferred", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("cancel_deferred", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_read_transaction<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyReadTransactionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_read_transaction() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("read_transaction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyReadTransactionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("read_transaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("read_transaction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_transaction_size<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyTransactionSizeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_transaction_size() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("transaction_size", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyTransactionSizeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("transaction_size", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("transaction_size", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tapos_block_num<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyTaposBlockNumArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tapos_block_num() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("tapos_block_num", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyTaposBlockNumResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("tapos_block_num", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("tapos_block_num", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tapos_block_prefix<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyTaposBlockPrefixArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tapos_block_prefix() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("tapos_block_prefix", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyTaposBlockPrefixResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("tapos_block_prefix", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("tapos_block_prefix", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_expiration<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyExpirationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_expiration() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("expiration", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyExpirationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("expiration", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("expiration", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_action<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyGetActionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_action(args._type, args.index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_action", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetActionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_action", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_action", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_context_free_data<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyGetContextFreeDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_context_free_data(args.index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_context_free_data", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetContextFreeDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_context_free_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_context_free_data", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_store_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbStoreI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_store_i64(args.scope, args.table, args.payer, args.id, args.data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_store_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbStoreI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_store_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_store_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_update_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbUpdateI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_update_i64(args.iterator, args.payer, args.data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_update_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbUpdateI64Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_update_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_update_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_remove_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbRemoveI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_remove_i64(args.iterator) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_remove_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbRemoveI64Result {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_remove_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_remove_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_get_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbGetI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_get_i64(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_get_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbGetI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_get_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_get_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_next_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbNextI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_next_i64(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_next_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbNextI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_next_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_next_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_previous_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbPreviousI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_previous_i64(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_previous_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbPreviousI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_previous_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_previous_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_find_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbFindI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_find_i64(args.code, args.scope, args.table, args.id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_find_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbFindI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_find_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_find_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_lowerbound_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbLowerboundI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_lowerbound_i64(args.code, args.scope, args.table, args.id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_lowerbound_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbLowerboundI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_lowerbound_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_lowerbound_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_upperbound_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbUpperboundI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_upperbound_i64(args.code, args.scope, args.table, args.id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_upperbound_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbUpperboundI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_upperbound_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_upperbound_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_end_i64<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbEndI64Args::read_from_in_protocol(i_prot)?;
    match handler.handle_db_end_i64(args.code, args.scope, args.table) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_end_i64", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbEndI64Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_end_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_end_i64", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_store<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64StoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_store(args.scope, args.table, args.payer, args.id, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_store", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64StoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_update<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64UpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_update(args.iterator, args.payer, args.secondary) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx64_update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64UpdateResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_remove<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64RemoveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_remove(args.iterator) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx64_remove", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64RemoveResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_next<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64NextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_next(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_next", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64NextResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_previous<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64PreviousArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_previous(args.iteratory) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_previous", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64PreviousResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_find_primary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64FindPrimaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_find_primary(args.code, args.scope, args.table, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_find_primary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64FindPrimaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_find_secondary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64FindSecondaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_find_secondary(args.code, args.scope, args.table, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_find_secondary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64FindSecondaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_lowerbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64LowerboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_lowerbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64LowerboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_upperbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64UpperboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_upperbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_upperbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64UpperboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx64_end<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx64EndArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx64_end(args.code, args.scope, args.table) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx64_end", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx64EndResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx64_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx64_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_store<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128StoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_store(args.scope, args.table, args.payer, args.id, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_store", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128StoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_update<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128UpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_update(args.iterator, args.payer, args.secondary) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx128_update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128UpdateResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_remove<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128RemoveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_remove(args.iterator) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx128_remove", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128RemoveResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_next<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128NextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_next(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_next", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128NextResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_previous<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128PreviousArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_previous(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_previous", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128PreviousResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_find_primary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128FindPrimaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_find_primary(args.code, args.scope, args.table, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_find_primary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128FindPrimaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_find_secondary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128FindSecondaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_find_secondary(args.code, args.scope, args.table, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_find_secondary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128FindSecondaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_lowerbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128LowerboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_lowerbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128LowerboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_upperbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128UpperboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_upperbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_upperbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128UpperboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx128_end<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx128EndArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx128_end(args.code, args.scope, args.table) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx128_end", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx128EndResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx128_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx128_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_store<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256StoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_store(args.scope, args.table, args.payer, args.id, args.data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_store", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256StoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_update<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256UpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_update(args.iterator, args.payer, args.data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx256_update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256UpdateResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_remove<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256RemoveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_remove(args.iterator) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx256_remove", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256RemoveResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_next<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256NextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_next(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_next", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256NextResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_previous<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256PreviousArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_previous(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_previous", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256PreviousResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_find_primary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256FindPrimaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_find_primary(args.code, args.scope, args.table, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_find_primary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256FindPrimaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_find_secondary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256FindSecondaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_find_secondary(args.code, args.scope, args.table, args.data) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_find_secondary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256FindSecondaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_lowerbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256LowerboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_lowerbound(args.code, args.scope, args.table, args.data, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_lowerbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256LowerboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_upperbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256UpperboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_upperbound(args.code, args.scope, args.table, args.data, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_upperbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256UpperboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx256_end<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdx256EndArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx256_end(args.code, args.scope, args.table) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx256_end", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdx256EndResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx256_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx256_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_store<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleStoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_store(args.scope, args.table, args.payer, args.id, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_store", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleStoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_update<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleUpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_update(args.iterator, args.payer, args.secondary) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleUpdateResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_remove<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleRemoveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_remove(args.iterator) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_remove", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleRemoveResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_next<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleNextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_next(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_next", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleNextResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_previous<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoublePreviousArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_previous(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_previous", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoublePreviousResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_find_primary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleFindPrimaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_find_primary(args.code, args.scope, args.table, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_find_primary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleFindPrimaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_find_secondary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleFindSecondaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_find_secondary(args.code, args.scope, args.table, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_find_secondary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleFindSecondaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_lowerbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleLowerboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_lowerbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleLowerboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_upperbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleUpperboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_upperbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_upperbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleUpperboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_double_end<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxDoubleEndArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_double_end(args.code, args.scope, args.table) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_double_end", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxDoubleEndResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_double_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_double_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_store<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleStoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_store(args.scope, args.table, args.payer, args.id, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_store", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleStoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_store", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_update<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleUpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_update(args.iterator, args.payer, args.secondary) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleUpdateResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_remove<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleRemoveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_remove(args.iterator) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_remove", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleRemoveResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_remove", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_next<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleNextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_next(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_next", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleNextResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_next", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_previous<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoublePreviousArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_previous(args.iterator) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_previous", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoublePreviousResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_previous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_find_primary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleFindPrimaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_find_primary(args.code, args.scope, args.table, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_find_primary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleFindPrimaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_find_primary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_find_secondary<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleFindSecondaryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_find_secondary(args.code, args.scope, args.table, args.secondary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_find_secondary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleFindSecondaryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_find_secondary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_lowerbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleLowerboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_lowerbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_lowerbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleLowerboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_lowerbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_upperbound<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleUpperboundArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_upperbound(args.code, args.scope, args.table, args.secondary, args.primary) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_upperbound", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleUpperboundResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_upperbound", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_db_idx_long_double_end<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyDbIdxLongDoubleEndArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_db_idx_long_double_end(args.code, args.scope, args.table) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("db_idx_long_double_end", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyDbIdxLongDoubleEndResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("db_idx_long_double_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("db_idx_long_double_end", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_action_return_value<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySetActionReturnValueArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_action_return_value(args.data) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("set_action_return_value", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySetActionReturnValueResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("set_action_return_value", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("set_action_return_value", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_code_hash<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyGetCodeHashArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_code_hash(args.account, args.struct_version) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_code_hash", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetCodeHashResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_code_hash", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_code_hash", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_block_num<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = ApplyGetBlockNumArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_block_num() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("get_block_num", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyGetBlockNumResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("get_block_num", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("get_block_num", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sha3<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplySha3Args::read_from_in_protocol(i_prot)?;
    match handler.handle_sha3(args.data, args.keccak) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sha3", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplySha3Result { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sha3", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sha3", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_blake2_f<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyBlake2FArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_blake2_f(args.rounds, args.state, args.msg, args.t0_offset, args.t1_offset, args.final_) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("blake2_f", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyBlake2FResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("blake2_f", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("blake2_f", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_k1_recover<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyK1RecoverArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_k1_recover(args.sig, args.dig) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("k1_recover", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyK1RecoverResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("k1_recover", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("k1_recover", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alt_bn128_add<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAltBn128AddArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alt_bn128_add(args.op1, args.op2) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("alt_bn128_add", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAltBn128AddResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alt_bn128_add", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alt_bn128_add", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alt_bn128_mul<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAltBn128MulArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alt_bn128_mul(args.g1, args.scalar) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("alt_bn128_mul", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAltBn128MulResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alt_bn128_mul", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alt_bn128_mul", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_alt_bn128_pair<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyAltBn128PairArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_alt_bn128_pair(args.pairs) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("alt_bn128_pair", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyAltBn128PairResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("alt_bn128_pair", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("alt_bn128_pair", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_mod_exp<H: ApplySyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ApplyModExpArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_mod_exp(args.base, args.exp, args.mod_) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("mod_exp", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ApplyModExpResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("mod_exp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("mod_exp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ApplySyncHandler> TProcessor for ApplySyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "end_apply" => {
        self.process_end_apply(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_active_producers" => {
        self.process_get_active_producers(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_resource_limits" => {
        self.process_get_resource_limits(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_resource_limits" => {
        self.process_set_resource_limits(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_proposed_producers" => {
        self.process_set_proposed_producers(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_proposed_producers_ex" => {
        self.process_set_proposed_producers_ex(message_ident.sequence_number, i_prot, o_prot)
      },
      "is_privileged" => {
        self.process_is_privileged(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_privileged" => {
        self.process_set_privileged(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_blockchain_parameters_packed" => {
        self.process_set_blockchain_parameters_packed(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_blockchain_parameters_packed" => {
        self.process_get_blockchain_parameters_packed(message_ident.sequence_number, i_prot, o_prot)
      },
      "preactivate_feature" => {
        self.process_preactivate_feature(message_ident.sequence_number, i_prot, o_prot)
      },
      "check_transaction_authorization" => {
        self.process_check_transaction_authorization(message_ident.sequence_number, i_prot, o_prot)
      },
      "check_permission_authorization" => {
        self.process_check_permission_authorization(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_permission_last_used" => {
        self.process_get_permission_last_used(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_account_creation_time" => {
        self.process_get_account_creation_time(message_ident.sequence_number, i_prot, o_prot)
      },
      "prints" => {
        self.process_prints(message_ident.sequence_number, i_prot, o_prot)
      },
      "prints_l" => {
        self.process_prints_l(message_ident.sequence_number, i_prot, o_prot)
      },
      "printi" => {
        self.process_printi(message_ident.sequence_number, i_prot, o_prot)
      },
      "printui" => {
        self.process_printui(message_ident.sequence_number, i_prot, o_prot)
      },
      "printi128" => {
        self.process_printi128(message_ident.sequence_number, i_prot, o_prot)
      },
      "printui128" => {
        self.process_printui128(message_ident.sequence_number, i_prot, o_prot)
      },
      "printsf" => {
        self.process_printsf(message_ident.sequence_number, i_prot, o_prot)
      },
      "printdf" => {
        self.process_printdf(message_ident.sequence_number, i_prot, o_prot)
      },
      "printqf" => {
        self.process_printqf(message_ident.sequence_number, i_prot, o_prot)
      },
      "printn" => {
        self.process_printn(message_ident.sequence_number, i_prot, o_prot)
      },
      "printhex" => {
        self.process_printhex(message_ident.sequence_number, i_prot, o_prot)
      },
      "action_data_size" => {
        self.process_action_data_size(message_ident.sequence_number, i_prot, o_prot)
      },
      "read_action_data" => {
        self.process_read_action_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "require_recipient" => {
        self.process_require_recipient(message_ident.sequence_number, i_prot, o_prot)
      },
      "require_auth" => {
        self.process_require_auth(message_ident.sequence_number, i_prot, o_prot)
      },
      "has_auth" => {
        self.process_has_auth(message_ident.sequence_number, i_prot, o_prot)
      },
      "require_auth2" => {
        self.process_require_auth2(message_ident.sequence_number, i_prot, o_prot)
      },
      "is_account" => {
        self.process_is_account(message_ident.sequence_number, i_prot, o_prot)
      },
      "send_inline" => {
        self.process_send_inline(message_ident.sequence_number, i_prot, o_prot)
      },
      "send_context_free_inline" => {
        self.process_send_context_free_inline(message_ident.sequence_number, i_prot, o_prot)
      },
      "publication_time" => {
        self.process_publication_time(message_ident.sequence_number, i_prot, o_prot)
      },
      "current_receiver" => {
        self.process_current_receiver(message_ident.sequence_number, i_prot, o_prot)
      },
      "eosio_assert" => {
        self.process_eosio_assert(message_ident.sequence_number, i_prot, o_prot)
      },
      "eosio_assert_message" => {
        self.process_eosio_assert_message(message_ident.sequence_number, i_prot, o_prot)
      },
      "eosio_assert_code" => {
        self.process_eosio_assert_code(message_ident.sequence_number, i_prot, o_prot)
      },
      "eosio_exit" => {
        self.process_eosio_exit(message_ident.sequence_number, i_prot, o_prot)
      },
      "current_time" => {
        self.process_current_time(message_ident.sequence_number, i_prot, o_prot)
      },
      "is_feature_activated" => {
        self.process_is_feature_activated(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_sender" => {
        self.process_get_sender(message_ident.sequence_number, i_prot, o_prot)
      },
      "assert_sha256" => {
        self.process_assert_sha256(message_ident.sequence_number, i_prot, o_prot)
      },
      "assert_sha1" => {
        self.process_assert_sha1(message_ident.sequence_number, i_prot, o_prot)
      },
      "assert_sha512" => {
        self.process_assert_sha512(message_ident.sequence_number, i_prot, o_prot)
      },
      "assert_ripemd160" => {
        self.process_assert_ripemd160(message_ident.sequence_number, i_prot, o_prot)
      },
      "sha256" => {
        self.process_sha256(message_ident.sequence_number, i_prot, o_prot)
      },
      "sha1" => {
        self.process_sha1(message_ident.sequence_number, i_prot, o_prot)
      },
      "sha512" => {
        self.process_sha512(message_ident.sequence_number, i_prot, o_prot)
      },
      "ripemd160" => {
        self.process_ripemd160(message_ident.sequence_number, i_prot, o_prot)
      },
      "recover_key" => {
        self.process_recover_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "assert_recover_key" => {
        self.process_assert_recover_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "send_deferred" => {
        self.process_send_deferred(message_ident.sequence_number, i_prot, o_prot)
      },
      "cancel_deferred" => {
        self.process_cancel_deferred(message_ident.sequence_number, i_prot, o_prot)
      },
      "read_transaction" => {
        self.process_read_transaction(message_ident.sequence_number, i_prot, o_prot)
      },
      "transaction_size" => {
        self.process_transaction_size(message_ident.sequence_number, i_prot, o_prot)
      },
      "tapos_block_num" => {
        self.process_tapos_block_num(message_ident.sequence_number, i_prot, o_prot)
      },
      "tapos_block_prefix" => {
        self.process_tapos_block_prefix(message_ident.sequence_number, i_prot, o_prot)
      },
      "expiration" => {
        self.process_expiration(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_action" => {
        self.process_get_action(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_context_free_data" => {
        self.process_get_context_free_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_store_i64" => {
        self.process_db_store_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_update_i64" => {
        self.process_db_update_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_remove_i64" => {
        self.process_db_remove_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_get_i64" => {
        self.process_db_get_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_next_i64" => {
        self.process_db_next_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_previous_i64" => {
        self.process_db_previous_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_find_i64" => {
        self.process_db_find_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_lowerbound_i64" => {
        self.process_db_lowerbound_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_upperbound_i64" => {
        self.process_db_upperbound_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_end_i64" => {
        self.process_db_end_i64(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_store" => {
        self.process_db_idx64_store(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_update" => {
        self.process_db_idx64_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_remove" => {
        self.process_db_idx64_remove(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_next" => {
        self.process_db_idx64_next(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_previous" => {
        self.process_db_idx64_previous(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_find_primary" => {
        self.process_db_idx64_find_primary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_find_secondary" => {
        self.process_db_idx64_find_secondary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_lowerbound" => {
        self.process_db_idx64_lowerbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_upperbound" => {
        self.process_db_idx64_upperbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx64_end" => {
        self.process_db_idx64_end(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_store" => {
        self.process_db_idx128_store(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_update" => {
        self.process_db_idx128_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_remove" => {
        self.process_db_idx128_remove(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_next" => {
        self.process_db_idx128_next(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_previous" => {
        self.process_db_idx128_previous(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_find_primary" => {
        self.process_db_idx128_find_primary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_find_secondary" => {
        self.process_db_idx128_find_secondary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_lowerbound" => {
        self.process_db_idx128_lowerbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_upperbound" => {
        self.process_db_idx128_upperbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx128_end" => {
        self.process_db_idx128_end(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_store" => {
        self.process_db_idx256_store(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_update" => {
        self.process_db_idx256_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_remove" => {
        self.process_db_idx256_remove(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_next" => {
        self.process_db_idx256_next(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_previous" => {
        self.process_db_idx256_previous(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_find_primary" => {
        self.process_db_idx256_find_primary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_find_secondary" => {
        self.process_db_idx256_find_secondary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_lowerbound" => {
        self.process_db_idx256_lowerbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_upperbound" => {
        self.process_db_idx256_upperbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx256_end" => {
        self.process_db_idx256_end(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_store" => {
        self.process_db_idx_double_store(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_update" => {
        self.process_db_idx_double_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_remove" => {
        self.process_db_idx_double_remove(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_next" => {
        self.process_db_idx_double_next(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_previous" => {
        self.process_db_idx_double_previous(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_find_primary" => {
        self.process_db_idx_double_find_primary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_find_secondary" => {
        self.process_db_idx_double_find_secondary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_lowerbound" => {
        self.process_db_idx_double_lowerbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_upperbound" => {
        self.process_db_idx_double_upperbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_double_end" => {
        self.process_db_idx_double_end(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_store" => {
        self.process_db_idx_long_double_store(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_update" => {
        self.process_db_idx_long_double_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_remove" => {
        self.process_db_idx_long_double_remove(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_next" => {
        self.process_db_idx_long_double_next(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_previous" => {
        self.process_db_idx_long_double_previous(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_find_primary" => {
        self.process_db_idx_long_double_find_primary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_find_secondary" => {
        self.process_db_idx_long_double_find_secondary(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_lowerbound" => {
        self.process_db_idx_long_double_lowerbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_upperbound" => {
        self.process_db_idx_long_double_upperbound(message_ident.sequence_number, i_prot, o_prot)
      },
      "db_idx_long_double_end" => {
        self.process_db_idx_long_double_end(message_ident.sequence_number, i_prot, o_prot)
      },
      "set_action_return_value" => {
        self.process_set_action_return_value(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_code_hash" => {
        self.process_get_code_hash(message_ident.sequence_number, i_prot, o_prot)
      },
      "get_block_num" => {
        self.process_get_block_num(message_ident.sequence_number, i_prot, o_prot)
      },
      "sha3" => {
        self.process_sha3(message_ident.sequence_number, i_prot, o_prot)
      },
      "blake2_f" => {
        self.process_blake2_f(message_ident.sequence_number, i_prot, o_prot)
      },
      "k1_recover" => {
        self.process_k1_recover(message_ident.sequence_number, i_prot, o_prot)
      },
      "alt_bn128_add" => {
        self.process_alt_bn128_add(message_ident.sequence_number, i_prot, o_prot)
      },
      "alt_bn128_mul" => {
        self.process_alt_bn128_mul(message_ident.sequence_number, i_prot, o_prot)
      },
      "alt_bn128_pair" => {
        self.process_alt_bn128_pair(message_ident.sequence_number, i_prot, o_prot)
      },
      "mod_exp" => {
        self.process_mod_exp(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ApplyEndApplyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEndApplyArgs {
}

impl ApplyEndApplyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEndApplyArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyEndApplyArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("end_apply_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyEndApplyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEndApplyResult {
  result_value: Option<i32>,
}

impl ApplyEndApplyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEndApplyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyEndApplyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyEndApplyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyEndApply"
          )
        )
      )
    }
  }
}

//
// ApplyGetActiveProducersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetActiveProducersArgs {
}

impl ApplyGetActiveProducersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetActiveProducersArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetActiveProducersArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_active_producers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetActiveProducersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetActiveProducersResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyGetActiveProducersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetActiveProducersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetActiveProducersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetActiveProducersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetActiveProducers"
          )
        )
      )
    }
  }
}

//
// ApplyGetResourceLimitsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetResourceLimitsArgs {
  account: Uint64,
}

impl ApplyGetResourceLimitsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetResourceLimitsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyGetResourceLimitsArgs.account", &f_1)?;
    let ret = ApplyGetResourceLimitsArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_resource_limits_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetResourceLimitsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetResourceLimitsResult {
  result_value: Option<GetResourceLimitsReturn>,
}

impl ApplyGetResourceLimitsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetResourceLimitsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<GetResourceLimitsReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = GetResourceLimitsReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetResourceLimitsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetResourceLimitsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<GetResourceLimitsReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetResourceLimits"
          )
        )
      )
    }
  }
}

//
// ApplySetResourceLimitsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetResourceLimitsArgs {
  account: Uint64,
  ram_bytes: i64,
  net_weight: i64,
  cpu_weight: i64,
}

impl ApplySetResourceLimitsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetResourceLimitsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySetResourceLimitsArgs.account", &f_1)?;
    verify_required_field_exists("ApplySetResourceLimitsArgs.ram_bytes", &f_2)?;
    verify_required_field_exists("ApplySetResourceLimitsArgs.net_weight", &f_3)?;
    verify_required_field_exists("ApplySetResourceLimitsArgs.cpu_weight", &f_4)?;
    let ret = ApplySetResourceLimitsArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
      ram_bytes: f_2.expect("auto-generated code should have checked for presence of required fields"),
      net_weight: f_3.expect("auto-generated code should have checked for presence of required fields"),
      cpu_weight: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_resource_limits_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ram_bytes", TType::I64, 2))?;
    o_prot.write_i64(self.ram_bytes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("net_weight", TType::I64, 3))?;
    o_prot.write_i64(self.net_weight)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpu_weight", TType::I64, 4))?;
    o_prot.write_i64(self.cpu_weight)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySetResourceLimitsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetResourceLimitsResult {
}

impl ApplySetResourceLimitsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetResourceLimitsResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySetResourceLimitsResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySetResourceLimitsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplySetProposedProducersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetProposedProducersArgs {
  producer_data: Vec<u8>,
}

impl ApplySetProposedProducersArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetProposedProducersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySetProposedProducersArgs.producer_data", &f_1)?;
    let ret = ApplySetProposedProducersArgs {
      producer_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_proposed_producers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("producer_data", TType::String, 1))?;
    o_prot.write_bytes(&self.producer_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySetProposedProducersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetProposedProducersResult {
  result_value: Option<i64>,
}

impl ApplySetProposedProducersResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetProposedProducersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySetProposedProducersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySetProposedProducersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplySetProposedProducers"
          )
        )
      )
    }
  }
}

//
// ApplySetProposedProducersExArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetProposedProducersExArgs {
  producer_data_format: Uint64,
  producer_data: Vec<u8>,
}

impl ApplySetProposedProducersExArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetProposedProducersExArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySetProposedProducersExArgs.producer_data_format", &f_1)?;
    verify_required_field_exists("ApplySetProposedProducersExArgs.producer_data", &f_2)?;
    let ret = ApplySetProposedProducersExArgs {
      producer_data_format: f_1.expect("auto-generated code should have checked for presence of required fields"),
      producer_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_proposed_producers_ex_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("producer_data_format", TType::Struct, 1))?;
    self.producer_data_format.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("producer_data", TType::String, 2))?;
    o_prot.write_bytes(&self.producer_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySetProposedProducersExResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetProposedProducersExResult {
  result_value: Option<i64>,
}

impl ApplySetProposedProducersExResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetProposedProducersExResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySetProposedProducersExResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySetProposedProducersExResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplySetProposedProducersEx"
          )
        )
      )
    }
  }
}

//
// ApplyIsPrivilegedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyIsPrivilegedArgs {
  account: Uint64,
}

impl ApplyIsPrivilegedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyIsPrivilegedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyIsPrivilegedArgs.account", &f_1)?;
    let ret = ApplyIsPrivilegedArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("is_privileged_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyIsPrivilegedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyIsPrivilegedResult {
  result_value: Option<bool>,
}

impl ApplyIsPrivilegedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyIsPrivilegedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyIsPrivilegedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyIsPrivilegedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyIsPrivileged"
          )
        )
      )
    }
  }
}

//
// ApplySetPrivilegedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetPrivilegedArgs {
  account: Uint64,
  is_priv: bool,
}

impl ApplySetPrivilegedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetPrivilegedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySetPrivilegedArgs.account", &f_1)?;
    verify_required_field_exists("ApplySetPrivilegedArgs.is_priv", &f_2)?;
    let ret = ApplySetPrivilegedArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
      is_priv: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_privileged_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("is_priv", TType::Bool, 2))?;
    o_prot.write_bool(self.is_priv)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySetPrivilegedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetPrivilegedResult {
}

impl ApplySetPrivilegedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetPrivilegedResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySetPrivilegedResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySetPrivilegedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplySetBlockchainParametersPackedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetBlockchainParametersPackedArgs {
  data: Vec<u8>,
}

impl ApplySetBlockchainParametersPackedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetBlockchainParametersPackedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySetBlockchainParametersPackedArgs.data", &f_1)?;
    let ret = ApplySetBlockchainParametersPackedArgs {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_blockchain_parameters_packed_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySetBlockchainParametersPackedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetBlockchainParametersPackedResult {
}

impl ApplySetBlockchainParametersPackedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetBlockchainParametersPackedResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySetBlockchainParametersPackedResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySetBlockchainParametersPackedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyGetBlockchainParametersPackedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetBlockchainParametersPackedArgs {
}

impl ApplyGetBlockchainParametersPackedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetBlockchainParametersPackedArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetBlockchainParametersPackedArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_blockchain_parameters_packed_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetBlockchainParametersPackedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetBlockchainParametersPackedResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyGetBlockchainParametersPackedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetBlockchainParametersPackedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetBlockchainParametersPackedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetBlockchainParametersPackedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetBlockchainParametersPacked"
          )
        )
      )
    }
  }
}

//
// ApplyPreactivateFeatureArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPreactivateFeatureArgs {
  feature_digest: Vec<u8>,
}

impl ApplyPreactivateFeatureArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPreactivateFeatureArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPreactivateFeatureArgs.feature_digest", &f_1)?;
    let ret = ApplyPreactivateFeatureArgs {
      feature_digest: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("preactivate_feature_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("feature_digest", TType::String, 1))?;
    o_prot.write_bytes(&self.feature_digest)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPreactivateFeatureResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPreactivateFeatureResult {
}

impl ApplyPreactivateFeatureResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPreactivateFeatureResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPreactivateFeatureResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPreactivateFeatureResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyCheckTransactionAuthorizationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCheckTransactionAuthorizationArgs {
  trx_data: Vec<u8>,
  pubkeys_data: Vec<u8>,
  perms_data: Vec<u8>,
}

impl ApplyCheckTransactionAuthorizationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCheckTransactionAuthorizationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyCheckTransactionAuthorizationArgs.trx_data", &f_1)?;
    verify_required_field_exists("ApplyCheckTransactionAuthorizationArgs.pubkeys_data", &f_2)?;
    verify_required_field_exists("ApplyCheckTransactionAuthorizationArgs.perms_data", &f_3)?;
    let ret = ApplyCheckTransactionAuthorizationArgs {
      trx_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      pubkeys_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      perms_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("check_transaction_authorization_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("trx_data", TType::String, 1))?;
    o_prot.write_bytes(&self.trx_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pubkeys_data", TType::String, 2))?;
    o_prot.write_bytes(&self.pubkeys_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("perms_data", TType::String, 3))?;
    o_prot.write_bytes(&self.perms_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyCheckTransactionAuthorizationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCheckTransactionAuthorizationResult {
  result_value: Option<i32>,
}

impl ApplyCheckTransactionAuthorizationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCheckTransactionAuthorizationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyCheckTransactionAuthorizationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyCheckTransactionAuthorizationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyCheckTransactionAuthorization"
          )
        )
      )
    }
  }
}

//
// ApplyCheckPermissionAuthorizationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCheckPermissionAuthorizationArgs {
  account: Uint64,
  permission: Uint64,
  pubkeys_data: Vec<u8>,
  perms_data: Vec<u8>,
  delay_us: Uint64,
}

impl ApplyCheckPermissionAuthorizationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCheckPermissionAuthorizationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyCheckPermissionAuthorizationArgs.account", &f_1)?;
    verify_required_field_exists("ApplyCheckPermissionAuthorizationArgs.permission", &f_2)?;
    verify_required_field_exists("ApplyCheckPermissionAuthorizationArgs.pubkeys_data", &f_3)?;
    verify_required_field_exists("ApplyCheckPermissionAuthorizationArgs.perms_data", &f_4)?;
    verify_required_field_exists("ApplyCheckPermissionAuthorizationArgs.delay_us", &f_5)?;
    let ret = ApplyCheckPermissionAuthorizationArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
      permission: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pubkeys_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      perms_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      delay_us: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("check_permission_authorization_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permission", TType::Struct, 2))?;
    self.permission.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pubkeys_data", TType::String, 3))?;
    o_prot.write_bytes(&self.pubkeys_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("perms_data", TType::String, 4))?;
    o_prot.write_bytes(&self.perms_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("delay_us", TType::Struct, 5))?;
    self.delay_us.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyCheckPermissionAuthorizationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCheckPermissionAuthorizationResult {
  result_value: Option<i32>,
}

impl ApplyCheckPermissionAuthorizationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCheckPermissionAuthorizationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyCheckPermissionAuthorizationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyCheckPermissionAuthorizationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyCheckPermissionAuthorization"
          )
        )
      )
    }
  }
}

//
// ApplyGetPermissionLastUsedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetPermissionLastUsedArgs {
  account: Uint64,
  permission: Uint64,
}

impl ApplyGetPermissionLastUsedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetPermissionLastUsedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyGetPermissionLastUsedArgs.account", &f_1)?;
    verify_required_field_exists("ApplyGetPermissionLastUsedArgs.permission", &f_2)?;
    let ret = ApplyGetPermissionLastUsedArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
      permission: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_permission_last_used_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permission", TType::Struct, 2))?;
    self.permission.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetPermissionLastUsedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetPermissionLastUsedResult {
  result_value: Option<i64>,
}

impl ApplyGetPermissionLastUsedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetPermissionLastUsedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetPermissionLastUsedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetPermissionLastUsedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetPermissionLastUsed"
          )
        )
      )
    }
  }
}

//
// ApplyGetAccountCreationTimeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetAccountCreationTimeArgs {
  account: Uint64,
}

impl ApplyGetAccountCreationTimeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetAccountCreationTimeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyGetAccountCreationTimeArgs.account", &f_1)?;
    let ret = ApplyGetAccountCreationTimeArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_account_creation_time_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetAccountCreationTimeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetAccountCreationTimeResult {
  result_value: Option<i64>,
}

impl ApplyGetAccountCreationTimeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetAccountCreationTimeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetAccountCreationTimeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetAccountCreationTimeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetAccountCreationTime"
          )
        )
      )
    }
  }
}

//
// ApplyPrintsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintsArgs {
  cstr: String,
}

impl ApplyPrintsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintsArgs.cstr", &f_1)?;
    let ret = ApplyPrintsArgs {
      cstr: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("prints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cstr", TType::String, 1))?;
    o_prot.write_string(&self.cstr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintsResult {
}

impl ApplyPrintsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintsResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintsResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintsLArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintsLArgs {
  cstr: Vec<u8>,
}

impl ApplyPrintsLArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintsLArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintsLArgs.cstr", &f_1)?;
    let ret = ApplyPrintsLArgs {
      cstr: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("prints_l_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cstr", TType::String, 1))?;
    o_prot.write_bytes(&self.cstr)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintsLResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintsLResult {
}

impl ApplyPrintsLResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintsLResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintsLResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintsLResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintiArgs {
  n: i64,
}

impl ApplyPrintiArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintiArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintiArgs.n", &f_1)?;
    let ret = ApplyPrintiArgs {
      n: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printi_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("n", TType::I64, 1))?;
    o_prot.write_i64(self.n)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintiResult {
}

impl ApplyPrintiResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintiResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintiResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintuiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintuiArgs {
  n: Uint64,
}

impl ApplyPrintuiArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintuiArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintuiArgs.n", &f_1)?;
    let ret = ApplyPrintuiArgs {
      n: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printui_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("n", TType::Struct, 1))?;
    self.n.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintuiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintuiResult {
}

impl ApplyPrintuiResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintuiResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintuiResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintuiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrinti128Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrinti128Args {
  value: Vec<u8>,
}

impl ApplyPrinti128Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrinti128Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrinti128Args.value", &f_1)?;
    let ret = ApplyPrinti128Args {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printi128_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrinti128Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrinti128Result {
}

impl ApplyPrinti128Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrinti128Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrinti128Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrinti128Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintui128Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintui128Args {
  value: Vec<u8>,
}

impl ApplyPrintui128Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintui128Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintui128Args.value", &f_1)?;
    let ret = ApplyPrintui128Args {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printui128_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintui128Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintui128Result {
}

impl ApplyPrintui128Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintui128Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintui128Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintui128Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintsfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintsfArgs {
  value: Vec<u8>,
}

impl ApplyPrintsfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintsfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintsfArgs.value", &f_1)?;
    let ret = ApplyPrintsfArgs {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printsf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintsfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintsfResult {
}

impl ApplyPrintsfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintsfResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintsfResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintsfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintdfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintdfArgs {
  value: Vec<u8>,
}

impl ApplyPrintdfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintdfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintdfArgs.value", &f_1)?;
    let ret = ApplyPrintdfArgs {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printdf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintdfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintdfResult {
}

impl ApplyPrintdfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintdfResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintdfResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintdfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintqfArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintqfArgs {
  value: Vec<u8>,
}

impl ApplyPrintqfArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintqfArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintqfArgs.value", &f_1)?;
    let ret = ApplyPrintqfArgs {
      value: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printqf_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 1))?;
    o_prot.write_bytes(&self.value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintqfResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintqfResult {
}

impl ApplyPrintqfResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintqfResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintqfResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintqfResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrintnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintnArgs {
  name: Uint64,
}

impl ApplyPrintnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrintnArgs.name", &f_1)?;
    let ret = ApplyPrintnArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printn_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrintnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrintnResult {
}

impl ApplyPrintnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrintnResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrintnResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrintnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPrinthexArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrinthexArgs {
  data: Vec<u8>,
}

impl ApplyPrinthexArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrinthexArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyPrinthexArgs.data", &f_1)?;
    let ret = ApplyPrinthexArgs {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("printhex_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPrinthexResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPrinthexResult {
}

impl ApplyPrinthexResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPrinthexResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPrinthexResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPrinthexResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyActionDataSizeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyActionDataSizeArgs {
}

impl ApplyActionDataSizeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyActionDataSizeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyActionDataSizeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("action_data_size_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyActionDataSizeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyActionDataSizeResult {
  result_value: Option<i32>,
}

impl ApplyActionDataSizeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyActionDataSizeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyActionDataSizeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyActionDataSizeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyActionDataSize"
          )
        )
      )
    }
  }
}

//
// ApplyReadActionDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyReadActionDataArgs {
}

impl ApplyReadActionDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyReadActionDataArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyReadActionDataArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("read_action_data_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyReadActionDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyReadActionDataResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyReadActionDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyReadActionDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyReadActionDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyReadActionDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyReadActionData"
          )
        )
      )
    }
  }
}

//
// ApplyRequireRecipientArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequireRecipientArgs {
  name: Uint64,
}

impl ApplyRequireRecipientArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequireRecipientArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyRequireRecipientArgs.name", &f_1)?;
    let ret = ApplyRequireRecipientArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("require_recipient_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyRequireRecipientResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequireRecipientResult {
}

impl ApplyRequireRecipientResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequireRecipientResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyRequireRecipientResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyRequireRecipientResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyRequireAuthArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequireAuthArgs {
  name: Uint64,
}

impl ApplyRequireAuthArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequireAuthArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyRequireAuthArgs.name", &f_1)?;
    let ret = ApplyRequireAuthArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("require_auth_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyRequireAuthResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequireAuthResult {
}

impl ApplyRequireAuthResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequireAuthResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyRequireAuthResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyRequireAuthResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyHasAuthArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyHasAuthArgs {
  name: Uint64,
}

impl ApplyHasAuthArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyHasAuthArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyHasAuthArgs.name", &f_1)?;
    let ret = ApplyHasAuthArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("has_auth_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyHasAuthResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyHasAuthResult {
  result_value: Option<bool>,
}

impl ApplyHasAuthResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyHasAuthResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyHasAuthResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyHasAuthResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyHasAuth"
          )
        )
      )
    }
  }
}

//
// ApplyRequireAuth2Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequireAuth2Args {
  name: Uint64,
  permission: Uint64,
}

impl ApplyRequireAuth2Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequireAuth2Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyRequireAuth2Args.name", &f_1)?;
    verify_required_field_exists("ApplyRequireAuth2Args.permission", &f_2)?;
    let ret = ApplyRequireAuth2Args {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      permission: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("require_auth2_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("permission", TType::Struct, 2))?;
    self.permission.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyRequireAuth2Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRequireAuth2Result {
}

impl ApplyRequireAuth2Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRequireAuth2Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyRequireAuth2Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyRequireAuth2Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyIsAccountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyIsAccountArgs {
  name: Uint64,
}

impl ApplyIsAccountArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyIsAccountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyIsAccountArgs.name", &f_1)?;
    let ret = ApplyIsAccountArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("is_account_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::Struct, 1))?;
    self.name.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyIsAccountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyIsAccountResult {
  result_value: Option<bool>,
}

impl ApplyIsAccountResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyIsAccountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyIsAccountResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyIsAccountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyIsAccount"
          )
        )
      )
    }
  }
}

//
// ApplySendInlineArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySendInlineArgs {
  serialized_action: Vec<u8>,
}

impl ApplySendInlineArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySendInlineArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySendInlineArgs.serialized_action", &f_1)?;
    let ret = ApplySendInlineArgs {
      serialized_action: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("send_inline_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serialized_action", TType::String, 1))?;
    o_prot.write_bytes(&self.serialized_action)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySendInlineResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySendInlineResult {
}

impl ApplySendInlineResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySendInlineResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySendInlineResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySendInlineResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplySendContextFreeInlineArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySendContextFreeInlineArgs {
  serialized_data: Vec<u8>,
}

impl ApplySendContextFreeInlineArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySendContextFreeInlineArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySendContextFreeInlineArgs.serialized_data", &f_1)?;
    let ret = ApplySendContextFreeInlineArgs {
      serialized_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("send_context_free_inline_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serialized_data", TType::String, 1))?;
    o_prot.write_bytes(&self.serialized_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySendContextFreeInlineResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySendContextFreeInlineResult {
}

impl ApplySendContextFreeInlineResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySendContextFreeInlineResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySendContextFreeInlineResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySendContextFreeInlineResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyPublicationTimeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPublicationTimeArgs {
}

impl ApplyPublicationTimeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPublicationTimeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPublicationTimeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("publication_time_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyPublicationTimeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyPublicationTimeResult {
  result_value: Option<Uint64>,
}

impl ApplyPublicationTimeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyPublicationTimeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyPublicationTimeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyPublicationTimeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Uint64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyPublicationTime"
          )
        )
      )
    }
  }
}

//
// ApplyCurrentReceiverArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCurrentReceiverArgs {
}

impl ApplyCurrentReceiverArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCurrentReceiverArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyCurrentReceiverArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("current_receiver_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyCurrentReceiverResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCurrentReceiverResult {
  result_value: Option<Uint64>,
}

impl ApplyCurrentReceiverResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCurrentReceiverResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyCurrentReceiverResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyCurrentReceiverResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Uint64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyCurrentReceiver"
          )
        )
      )
    }
  }
}

//
// ApplyEosioAssertArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioAssertArgs {
  test: bool,
  msg: Vec<u8>,
}

impl ApplyEosioAssertArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioAssertArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyEosioAssertArgs.test", &f_1)?;
    verify_required_field_exists("ApplyEosioAssertArgs.msg", &f_2)?;
    let ret = ApplyEosioAssertArgs {
      test: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("eosio_assert_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("test", TType::Bool, 1))?;
    o_prot.write_bool(self.test)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::String, 2))?;
    o_prot.write_bytes(&self.msg)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyEosioAssertResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioAssertResult {
}

impl ApplyEosioAssertResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioAssertResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyEosioAssertResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyEosioAssertResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyEosioAssertMessageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioAssertMessageArgs {
  test: bool,
  msg: Vec<u8>,
}

impl ApplyEosioAssertMessageArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioAssertMessageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyEosioAssertMessageArgs.test", &f_1)?;
    verify_required_field_exists("ApplyEosioAssertMessageArgs.msg", &f_2)?;
    let ret = ApplyEosioAssertMessageArgs {
      test: f_1.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("eosio_assert_message_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("test", TType::Bool, 1))?;
    o_prot.write_bool(self.test)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::String, 2))?;
    o_prot.write_bytes(&self.msg)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyEosioAssertMessageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioAssertMessageResult {
}

impl ApplyEosioAssertMessageResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioAssertMessageResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyEosioAssertMessageResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyEosioAssertMessageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyEosioAssertCodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioAssertCodeArgs {
  test: bool,
  code: Uint64,
}

impl ApplyEosioAssertCodeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioAssertCodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyEosioAssertCodeArgs.test", &f_1)?;
    verify_required_field_exists("ApplyEosioAssertCodeArgs.code", &f_2)?;
    let ret = ApplyEosioAssertCodeArgs {
      test: f_1.expect("auto-generated code should have checked for presence of required fields"),
      code: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("eosio_assert_code_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("test", TType::Bool, 1))?;
    o_prot.write_bool(self.test)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 2))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyEosioAssertCodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioAssertCodeResult {
}

impl ApplyEosioAssertCodeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioAssertCodeResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyEosioAssertCodeResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyEosioAssertCodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyEosioExitArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioExitArgs {
  code: i32,
}

impl ApplyEosioExitArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioExitArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyEosioExitArgs.code", &f_1)?;
    let ret = ApplyEosioExitArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("eosio_exit_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
    o_prot.write_i32(self.code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyEosioExitResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyEosioExitResult {
}

impl ApplyEosioExitResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyEosioExitResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyEosioExitResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyEosioExitResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyCurrentTimeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCurrentTimeArgs {
}

impl ApplyCurrentTimeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCurrentTimeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyCurrentTimeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("current_time_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyCurrentTimeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCurrentTimeResult {
  result_value: Option<Uint64>,
}

impl ApplyCurrentTimeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCurrentTimeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyCurrentTimeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyCurrentTimeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Uint64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyCurrentTime"
          )
        )
      )
    }
  }
}

//
// ApplyIsFeatureActivatedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyIsFeatureActivatedArgs {
  feature_digest: Vec<u8>,
}

impl ApplyIsFeatureActivatedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyIsFeatureActivatedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyIsFeatureActivatedArgs.feature_digest", &f_1)?;
    let ret = ApplyIsFeatureActivatedArgs {
      feature_digest: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("is_feature_activated_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("feature_digest", TType::String, 1))?;
    o_prot.write_bytes(&self.feature_digest)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyIsFeatureActivatedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyIsFeatureActivatedResult {
  result_value: Option<bool>,
}

impl ApplyIsFeatureActivatedResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyIsFeatureActivatedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyIsFeatureActivatedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyIsFeatureActivatedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyIsFeatureActivated"
          )
        )
      )
    }
  }
}

//
// ApplyGetSenderArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetSenderArgs {
}

impl ApplyGetSenderArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetSenderArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetSenderArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_sender_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetSenderResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetSenderResult {
  result_value: Option<Uint64>,
}

impl ApplyGetSenderResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetSenderResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetSenderResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetSenderResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Uint64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetSender"
          )
        )
      )
    }
  }
}

//
// ApplyAssertSha256Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertSha256Args {
  data: Vec<u8>,
  hash: Vec<u8>,
}

impl ApplyAssertSha256Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertSha256Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAssertSha256Args.data", &f_1)?;
    verify_required_field_exists("ApplyAssertSha256Args.hash", &f_2)?;
    let ret = ApplyAssertSha256Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("assert_sha256_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hash", TType::String, 2))?;
    o_prot.write_bytes(&self.hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAssertSha256Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertSha256Result {
}

impl ApplyAssertSha256Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertSha256Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAssertSha256Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAssertSha256Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyAssertSha1Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertSha1Args {
  data: Vec<u8>,
  hash: Vec<u8>,
}

impl ApplyAssertSha1Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertSha1Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAssertSha1Args.data", &f_1)?;
    verify_required_field_exists("ApplyAssertSha1Args.hash", &f_2)?;
    let ret = ApplyAssertSha1Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("assert_sha1_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hash", TType::String, 2))?;
    o_prot.write_bytes(&self.hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAssertSha1Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertSha1Result {
}

impl ApplyAssertSha1Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertSha1Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAssertSha1Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAssertSha1Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyAssertSha512Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertSha512Args {
  data: Vec<u8>,
  hash: Vec<u8>,
}

impl ApplyAssertSha512Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertSha512Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAssertSha512Args.data", &f_1)?;
    verify_required_field_exists("ApplyAssertSha512Args.hash", &f_2)?;
    let ret = ApplyAssertSha512Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("assert_sha512_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hash", TType::String, 2))?;
    o_prot.write_bytes(&self.hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAssertSha512Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertSha512Result {
}

impl ApplyAssertSha512Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertSha512Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAssertSha512Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAssertSha512Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyAssertRipemd160Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertRipemd160Args {
  data: Vec<u8>,
  hash: Vec<u8>,
}

impl ApplyAssertRipemd160Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertRipemd160Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAssertRipemd160Args.data", &f_1)?;
    verify_required_field_exists("ApplyAssertRipemd160Args.hash", &f_2)?;
    let ret = ApplyAssertRipemd160Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      hash: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("assert_ripemd160_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hash", TType::String, 2))?;
    o_prot.write_bytes(&self.hash)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAssertRipemd160Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertRipemd160Result {
}

impl ApplyAssertRipemd160Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertRipemd160Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAssertRipemd160Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAssertRipemd160Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplySha256Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha256Args {
  data: Vec<u8>,
}

impl ApplySha256Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha256Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySha256Args.data", &f_1)?;
    let ret = ApplySha256Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sha256_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySha256Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha256Result {
  result_value: Option<Vec<u8>>,
}

impl ApplySha256Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha256Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySha256Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySha256Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplySha256"
          )
        )
      )
    }
  }
}

//
// ApplySha1Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha1Args {
  data: Vec<u8>,
}

impl ApplySha1Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha1Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySha1Args.data", &f_1)?;
    let ret = ApplySha1Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sha1_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySha1Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha1Result {
  result_value: Option<Vec<u8>>,
}

impl ApplySha1Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha1Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySha1Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySha1Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplySha1"
          )
        )
      )
    }
  }
}

//
// ApplySha512Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha512Args {
  data: Vec<u8>,
}

impl ApplySha512Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha512Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySha512Args.data", &f_1)?;
    let ret = ApplySha512Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sha512_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySha512Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha512Result {
  result_value: Option<Vec<u8>>,
}

impl ApplySha512Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha512Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySha512Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySha512Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplySha512"
          )
        )
      )
    }
  }
}

//
// ApplyRipemd160Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRipemd160Args {
  data: Vec<u8>,
}

impl ApplyRipemd160Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRipemd160Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyRipemd160Args.data", &f_1)?;
    let ret = ApplyRipemd160Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ripemd160_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyRipemd160Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRipemd160Result {
  result_value: Option<Vec<u8>>,
}

impl ApplyRipemd160Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRipemd160Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyRipemd160Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyRipemd160Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyRipemd160"
          )
        )
      )
    }
  }
}

//
// ApplyRecoverKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRecoverKeyArgs {
  digest: Vec<u8>,
  sig: Vec<u8>,
}

impl ApplyRecoverKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRecoverKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyRecoverKeyArgs.digest", &f_1)?;
    verify_required_field_exists("ApplyRecoverKeyArgs.sig", &f_2)?;
    let ret = ApplyRecoverKeyArgs {
      digest: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sig: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("recover_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("digest", TType::String, 1))?;
    o_prot.write_bytes(&self.digest)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sig", TType::String, 2))?;
    o_prot.write_bytes(&self.sig)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyRecoverKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyRecoverKeyResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyRecoverKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyRecoverKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyRecoverKeyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyRecoverKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyRecoverKey"
          )
        )
      )
    }
  }
}

//
// ApplyAssertRecoverKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertRecoverKeyArgs {
  digest: Vec<u8>,
  sig: Vec<u8>,
  pub_: Vec<u8>,
}

impl ApplyAssertRecoverKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertRecoverKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAssertRecoverKeyArgs.digest", &f_1)?;
    verify_required_field_exists("ApplyAssertRecoverKeyArgs.sig", &f_2)?;
    verify_required_field_exists("ApplyAssertRecoverKeyArgs.pub_", &f_3)?;
    let ret = ApplyAssertRecoverKeyArgs {
      digest: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sig: f_2.expect("auto-generated code should have checked for presence of required fields"),
      pub_: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("assert_recover_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("digest", TType::String, 1))?;
    o_prot.write_bytes(&self.digest)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sig", TType::String, 2))?;
    o_prot.write_bytes(&self.sig)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pub", TType::String, 3))?;
    o_prot.write_bytes(&self.pub_)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAssertRecoverKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAssertRecoverKeyResult {
}

impl ApplyAssertRecoverKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAssertRecoverKeyResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAssertRecoverKeyResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAssertRecoverKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplySendDeferredArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySendDeferredArgs {
  sender_id: Vec<u8>,
  payer: Uint64,
  serialized_transaction: Vec<u8>,
  replace_existing: i32,
}

impl ApplySendDeferredArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySendDeferredArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySendDeferredArgs.sender_id", &f_1)?;
    verify_required_field_exists("ApplySendDeferredArgs.payer", &f_2)?;
    verify_required_field_exists("ApplySendDeferredArgs.serialized_transaction", &f_3)?;
    verify_required_field_exists("ApplySendDeferredArgs.replace_existing", &f_4)?;
    let ret = ApplySendDeferredArgs {
      sender_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      serialized_transaction: f_3.expect("auto-generated code should have checked for presence of required fields"),
      replace_existing: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("send_deferred_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sender_id", TType::String, 1))?;
    o_prot.write_bytes(&self.sender_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 2))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serialized_transaction", TType::String, 3))?;
    o_prot.write_bytes(&self.serialized_transaction)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("replace_existing", TType::I32, 4))?;
    o_prot.write_i32(self.replace_existing)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySendDeferredResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySendDeferredResult {
}

impl ApplySendDeferredResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySendDeferredResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySendDeferredResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySendDeferredResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyCancelDeferredArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCancelDeferredArgs {
  sender_id: Vec<u8>,
}

impl ApplyCancelDeferredArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCancelDeferredArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyCancelDeferredArgs.sender_id", &f_1)?;
    let ret = ApplyCancelDeferredArgs {
      sender_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cancel_deferred_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sender_id", TType::String, 1))?;
    o_prot.write_bytes(&self.sender_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyCancelDeferredResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyCancelDeferredResult {
  result_value: Option<i32>,
}

impl ApplyCancelDeferredResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyCancelDeferredResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyCancelDeferredResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyCancelDeferredResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyCancelDeferred"
          )
        )
      )
    }
  }
}

//
// ApplyReadTransactionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyReadTransactionArgs {
}

impl ApplyReadTransactionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyReadTransactionArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyReadTransactionArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("read_transaction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyReadTransactionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyReadTransactionResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyReadTransactionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyReadTransactionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyReadTransactionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyReadTransactionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyReadTransaction"
          )
        )
      )
    }
  }
}

//
// ApplyTransactionSizeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyTransactionSizeArgs {
}

impl ApplyTransactionSizeArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyTransactionSizeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyTransactionSizeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("transaction_size_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyTransactionSizeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyTransactionSizeResult {
  result_value: Option<i32>,
}

impl ApplyTransactionSizeResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyTransactionSizeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyTransactionSizeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyTransactionSizeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyTransactionSize"
          )
        )
      )
    }
  }
}

//
// ApplyTaposBlockNumArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyTaposBlockNumArgs {
}

impl ApplyTaposBlockNumArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyTaposBlockNumArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyTaposBlockNumArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("tapos_block_num_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyTaposBlockNumResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyTaposBlockNumResult {
  result_value: Option<i32>,
}

impl ApplyTaposBlockNumResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyTaposBlockNumResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyTaposBlockNumResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyTaposBlockNumResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyTaposBlockNum"
          )
        )
      )
    }
  }
}

//
// ApplyTaposBlockPrefixArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyTaposBlockPrefixArgs {
}

impl ApplyTaposBlockPrefixArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyTaposBlockPrefixArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyTaposBlockPrefixArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("tapos_block_prefix_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyTaposBlockPrefixResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyTaposBlockPrefixResult {
  result_value: Option<i32>,
}

impl ApplyTaposBlockPrefixResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyTaposBlockPrefixResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyTaposBlockPrefixResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyTaposBlockPrefixResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyTaposBlockPrefix"
          )
        )
      )
    }
  }
}

//
// ApplyExpirationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyExpirationArgs {
}

impl ApplyExpirationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyExpirationArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyExpirationArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("expiration_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyExpirationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyExpirationResult {
  result_value: Option<i64>,
}

impl ApplyExpirationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyExpirationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyExpirationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyExpirationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyExpiration"
          )
        )
      )
    }
  }
}

//
// ApplyGetActionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetActionArgs {
  _type: i32,
  index: i32,
}

impl ApplyGetActionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetActionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyGetActionArgs._type", &f_1)?;
    verify_required_field_exists("ApplyGetActionArgs.index", &f_2)?;
    let ret = ApplyGetActionArgs {
      _type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_action_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("_type", TType::I32, 1))?;
    o_prot.write_i32(self._type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index", TType::I32, 2))?;
    o_prot.write_i32(self.index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetActionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetActionResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyGetActionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetActionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetActionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetActionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetAction"
          )
        )
      )
    }
  }
}

//
// ApplyGetContextFreeDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetContextFreeDataArgs {
  index: i32,
}

impl ApplyGetContextFreeDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetContextFreeDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyGetContextFreeDataArgs.index", &f_1)?;
    let ret = ApplyGetContextFreeDataArgs {
      index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_context_free_data_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("index", TType::I32, 1))?;
    o_prot.write_i32(self.index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetContextFreeDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetContextFreeDataResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyGetContextFreeDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetContextFreeDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetContextFreeDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetContextFreeDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetContextFreeData"
          )
        )
      )
    }
  }
}

//
// ApplyDbStoreI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbStoreI64Args {
  scope: Uint64,
  table: Uint64,
  payer: Uint64,
  id: Uint64,
  data: Vec<u8>,
}

impl ApplyDbStoreI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbStoreI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbStoreI64Args.scope", &f_1)?;
    verify_required_field_exists("ApplyDbStoreI64Args.table", &f_2)?;
    verify_required_field_exists("ApplyDbStoreI64Args.payer", &f_3)?;
    verify_required_field_exists("ApplyDbStoreI64Args.id", &f_4)?;
    verify_required_field_exists("ApplyDbStoreI64Args.data", &f_5)?;
    let ret = ApplyDbStoreI64Args {
      scope: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table: f_2.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      data: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_store_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 1))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 2))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 3))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 5))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbStoreI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbStoreI64Result {
  result_value: Option<i32>,
}

impl ApplyDbStoreI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbStoreI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbStoreI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbStoreI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbStoreI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbUpdateI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbUpdateI64Args {
  iterator: i32,
  payer: Uint64,
  data: Vec<u8>,
}

impl ApplyDbUpdateI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbUpdateI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbUpdateI64Args.iterator", &f_1)?;
    verify_required_field_exists("ApplyDbUpdateI64Args.payer", &f_2)?;
    verify_required_field_exists("ApplyDbUpdateI64Args.data", &f_3)?;
    let ret = ApplyDbUpdateI64Args {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_update_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 2))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 3))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbUpdateI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbUpdateI64Result {
}

impl ApplyDbUpdateI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbUpdateI64Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbUpdateI64Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbUpdateI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbRemoveI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbRemoveI64Args {
  iterator: i32,
}

impl ApplyDbRemoveI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbRemoveI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbRemoveI64Args.iterator", &f_1)?;
    let ret = ApplyDbRemoveI64Args {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_remove_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbRemoveI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbRemoveI64Result {
}

impl ApplyDbRemoveI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbRemoveI64Result> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbRemoveI64Result {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbRemoveI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbGetI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbGetI64Args {
  iterator: i32,
}

impl ApplyDbGetI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbGetI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbGetI64Args.iterator", &f_1)?;
    let ret = ApplyDbGetI64Args {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_get_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbGetI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbGetI64Result {
  result_value: Option<Vec<u8>>,
}

impl ApplyDbGetI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbGetI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbGetI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbGetI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbGetI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbNextI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbNextI64Args {
  iterator: i32,
}

impl ApplyDbNextI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbNextI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbNextI64Args.iterator", &f_1)?;
    let ret = ApplyDbNextI64Args {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_next_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbNextI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbNextI64Result {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbNextI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbNextI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbNextI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbNextI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbNextI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbPreviousI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbPreviousI64Args {
  iterator: i32,
}

impl ApplyDbPreviousI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbPreviousI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbPreviousI64Args.iterator", &f_1)?;
    let ret = ApplyDbPreviousI64Args {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_previous_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbPreviousI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbPreviousI64Result {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbPreviousI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbPreviousI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbPreviousI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbPreviousI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbPreviousI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbFindI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbFindI64Args {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  id: Uint64,
}

impl ApplyDbFindI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbFindI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbFindI64Args.code", &f_1)?;
    verify_required_field_exists("ApplyDbFindI64Args.scope", &f_2)?;
    verify_required_field_exists("ApplyDbFindI64Args.table", &f_3)?;
    verify_required_field_exists("ApplyDbFindI64Args.id", &f_4)?;
    let ret = ApplyDbFindI64Args {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_find_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbFindI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbFindI64Result {
  result_value: Option<i32>,
}

impl ApplyDbFindI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbFindI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbFindI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbFindI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbFindI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbLowerboundI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbLowerboundI64Args {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  id: Uint64,
}

impl ApplyDbLowerboundI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbLowerboundI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbLowerboundI64Args.code", &f_1)?;
    verify_required_field_exists("ApplyDbLowerboundI64Args.scope", &f_2)?;
    verify_required_field_exists("ApplyDbLowerboundI64Args.table", &f_3)?;
    verify_required_field_exists("ApplyDbLowerboundI64Args.id", &f_4)?;
    let ret = ApplyDbLowerboundI64Args {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_lowerbound_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbLowerboundI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbLowerboundI64Result {
  result_value: Option<i32>,
}

impl ApplyDbLowerboundI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbLowerboundI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbLowerboundI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbLowerboundI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbLowerboundI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbUpperboundI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbUpperboundI64Args {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  id: Uint64,
}

impl ApplyDbUpperboundI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbUpperboundI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbUpperboundI64Args.code", &f_1)?;
    verify_required_field_exists("ApplyDbUpperboundI64Args.scope", &f_2)?;
    verify_required_field_exists("ApplyDbUpperboundI64Args.table", &f_3)?;
    verify_required_field_exists("ApplyDbUpperboundI64Args.id", &f_4)?;
    let ret = ApplyDbUpperboundI64Args {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_upperbound_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbUpperboundI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbUpperboundI64Result {
  result_value: Option<i32>,
}

impl ApplyDbUpperboundI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbUpperboundI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbUpperboundI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbUpperboundI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbUpperboundI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbEndI64Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbEndI64Args {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
}

impl ApplyDbEndI64Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbEndI64Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbEndI64Args.code", &f_1)?;
    verify_required_field_exists("ApplyDbEndI64Args.scope", &f_2)?;
    verify_required_field_exists("ApplyDbEndI64Args.table", &f_3)?;
    let ret = ApplyDbEndI64Args {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_end_i64_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbEndI64Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbEndI64Result {
  result_value: Option<i32>,
}

impl ApplyDbEndI64Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbEndI64Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbEndI64Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbEndI64Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbEndI64"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64StoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64StoreArgs {
  scope: Uint64,
  table: Uint64,
  payer: Uint64,
  id: Uint64,
  secondary: Uint64,
}

impl ApplyDbIdx64StoreArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64StoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64StoreArgs.scope", &f_1)?;
    verify_required_field_exists("ApplyDbIdx64StoreArgs.table", &f_2)?;
    verify_required_field_exists("ApplyDbIdx64StoreArgs.payer", &f_3)?;
    verify_required_field_exists("ApplyDbIdx64StoreArgs.id", &f_4)?;
    verify_required_field_exists("ApplyDbIdx64StoreArgs.secondary", &f_5)?;
    let ret = ApplyDbIdx64StoreArgs {
      scope: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table: f_2.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_store_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 1))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 2))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 3))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::Struct, 5))?;
    self.secondary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64StoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64StoreResult {
  result_value: Option<i32>,
}

impl ApplyDbIdx64StoreResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64StoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64StoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64StoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64Store"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64UpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64UpdateArgs {
  iterator: i32,
  payer: Uint64,
  secondary: Uint64,
}

impl ApplyDbIdx64UpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64UpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64UpdateArgs.iterator", &f_1)?;
    verify_required_field_exists("ApplyDbIdx64UpdateArgs.payer", &f_2)?;
    verify_required_field_exists("ApplyDbIdx64UpdateArgs.secondary", &f_3)?;
    let ret = ApplyDbIdx64UpdateArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 2))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::Struct, 3))?;
    self.secondary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64UpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64UpdateResult {
}

impl ApplyDbIdx64UpdateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64UpdateResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64UpdateResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64UpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdx64RemoveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64RemoveArgs {
  iterator: i32,
}

impl ApplyDbIdx64RemoveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64RemoveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64RemoveArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx64RemoveArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_remove_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64RemoveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64RemoveResult {
}

impl ApplyDbIdx64RemoveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64RemoveResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64RemoveResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64RemoveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdx64NextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64NextArgs {
  iterator: i32,
}

impl ApplyDbIdx64NextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64NextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64NextArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx64NextArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_next_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64NextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64NextResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdx64NextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64NextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64NextResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64NextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64Next"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64PreviousArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64PreviousArgs {
  iteratory: i32,
}

impl ApplyDbIdx64PreviousArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64PreviousArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64PreviousArgs.iteratory", &f_1)?;
    let ret = ApplyDbIdx64PreviousArgs {
      iteratory: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_previous_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iteratory", TType::I32, 1))?;
    o_prot.write_i32(self.iteratory)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64PreviousResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64PreviousResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdx64PreviousResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64PreviousResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64PreviousResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64PreviousResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64Previous"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64FindPrimaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64FindPrimaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  primary: Uint64,
}

impl ApplyDbIdx64FindPrimaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64FindPrimaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64FindPrimaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx64FindPrimaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx64FindPrimaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx64FindPrimaryArgs.primary", &f_4)?;
    let ret = ApplyDbIdx64FindPrimaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_find_primary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 4))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64FindPrimaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64FindPrimaryResult {
  result_value: Option<FindPrimaryReturn>,
}

impl ApplyDbIdx64FindPrimaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64FindPrimaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindPrimaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindPrimaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64FindPrimaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64FindPrimaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindPrimaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64FindPrimary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64FindSecondaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64FindSecondaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Uint64,
}

impl ApplyDbIdx64FindSecondaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64FindSecondaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64FindSecondaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx64FindSecondaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx64FindSecondaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx64FindSecondaryArgs.secondary", &f_4)?;
    let ret = ApplyDbIdx64FindSecondaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_find_secondary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::Struct, 4))?;
    self.secondary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64FindSecondaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64FindSecondaryResult {
  result_value: Option<FindSecondaryReturn>,
}

impl ApplyDbIdx64FindSecondaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64FindSecondaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindSecondaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindSecondaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64FindSecondaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64FindSecondaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindSecondaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64FindSecondary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64LowerboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64LowerboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Uint64,
  primary: Uint64,
}

impl ApplyDbIdx64LowerboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64LowerboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64LowerboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx64LowerboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx64LowerboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx64LowerboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdx64LowerboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdx64LowerboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_lowerbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::Struct, 4))?;
    self.secondary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64LowerboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64LowerboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdx64LowerboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64LowerboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64LowerboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64LowerboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64Lowerbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64UpperboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64UpperboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Uint64,
  primary: Uint64,
}

impl ApplyDbIdx64UpperboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64UpperboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64UpperboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx64UpperboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx64UpperboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx64UpperboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdx64UpperboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdx64UpperboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_upperbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::Struct, 4))?;
    self.secondary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64UpperboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64UpperboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdx64UpperboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64UpperboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64UpperboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64UpperboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64Upperbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx64EndArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64EndArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
}

impl ApplyDbIdx64EndArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64EndArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx64EndArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx64EndArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx64EndArgs.table", &f_3)?;
    let ret = ApplyDbIdx64EndArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx64_end_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx64EndResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx64EndResult {
  result_value: Option<i32>,
}

impl ApplyDbIdx64EndResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx64EndResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx64EndResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx64EndResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx64End"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128StoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128StoreArgs {
  scope: Uint64,
  table: Uint64,
  payer: Uint64,
  id: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdx128StoreArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128StoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128StoreArgs.scope", &f_1)?;
    verify_required_field_exists("ApplyDbIdx128StoreArgs.table", &f_2)?;
    verify_required_field_exists("ApplyDbIdx128StoreArgs.payer", &f_3)?;
    verify_required_field_exists("ApplyDbIdx128StoreArgs.id", &f_4)?;
    verify_required_field_exists("ApplyDbIdx128StoreArgs.secondary", &f_5)?;
    let ret = ApplyDbIdx128StoreArgs {
      scope: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table: f_2.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_store_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 1))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 2))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 3))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 5))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128StoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128StoreResult {
  result_value: Option<i32>,
}

impl ApplyDbIdx128StoreResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128StoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128StoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128StoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128Store"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128UpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128UpdateArgs {
  iterator: i32,
  payer: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdx128UpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128UpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128UpdateArgs.iterator", &f_1)?;
    verify_required_field_exists("ApplyDbIdx128UpdateArgs.payer", &f_2)?;
    verify_required_field_exists("ApplyDbIdx128UpdateArgs.secondary", &f_3)?;
    let ret = ApplyDbIdx128UpdateArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 2))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 3))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128UpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128UpdateResult {
}

impl ApplyDbIdx128UpdateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128UpdateResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128UpdateResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128UpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdx128RemoveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128RemoveArgs {
  iterator: i32,
}

impl ApplyDbIdx128RemoveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128RemoveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128RemoveArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx128RemoveArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_remove_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128RemoveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128RemoveResult {
}

impl ApplyDbIdx128RemoveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128RemoveResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128RemoveResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128RemoveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdx128NextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128NextArgs {
  iterator: i32,
}

impl ApplyDbIdx128NextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128NextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128NextArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx128NextArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_next_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128NextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128NextResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdx128NextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128NextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128NextResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128NextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128Next"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128PreviousArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128PreviousArgs {
  iterator: i32,
}

impl ApplyDbIdx128PreviousArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128PreviousArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128PreviousArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx128PreviousArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_previous_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128PreviousResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128PreviousResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdx128PreviousResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128PreviousResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128PreviousResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128PreviousResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128Previous"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128FindPrimaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128FindPrimaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  primary: Uint64,
}

impl ApplyDbIdx128FindPrimaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128FindPrimaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128FindPrimaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx128FindPrimaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx128FindPrimaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx128FindPrimaryArgs.primary", &f_4)?;
    let ret = ApplyDbIdx128FindPrimaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_find_primary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 4))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128FindPrimaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128FindPrimaryResult {
  result_value: Option<FindPrimaryReturn>,
}

impl ApplyDbIdx128FindPrimaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128FindPrimaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindPrimaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindPrimaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128FindPrimaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128FindPrimaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindPrimaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128FindPrimary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128FindSecondaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128FindSecondaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdx128FindSecondaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128FindSecondaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128FindSecondaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx128FindSecondaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx128FindSecondaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx128FindSecondaryArgs.secondary", &f_4)?;
    let ret = ApplyDbIdx128FindSecondaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_find_secondary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128FindSecondaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128FindSecondaryResult {
  result_value: Option<FindSecondaryReturn>,
}

impl ApplyDbIdx128FindSecondaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128FindSecondaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindSecondaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindSecondaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128FindSecondaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128FindSecondaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindSecondaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128FindSecondary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128LowerboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128LowerboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdx128LowerboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128LowerboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128LowerboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx128LowerboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx128LowerboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx128LowerboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdx128LowerboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdx128LowerboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_lowerbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128LowerboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128LowerboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdx128LowerboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128LowerboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128LowerboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128LowerboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128Lowerbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128UpperboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128UpperboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdx128UpperboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128UpperboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128UpperboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx128UpperboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx128UpperboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx128UpperboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdx128UpperboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdx128UpperboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_upperbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128UpperboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128UpperboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdx128UpperboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128UpperboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128UpperboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128UpperboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128Upperbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx128EndArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128EndArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
}

impl ApplyDbIdx128EndArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128EndArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx128EndArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx128EndArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx128EndArgs.table", &f_3)?;
    let ret = ApplyDbIdx128EndArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx128_end_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx128EndResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx128EndResult {
  result_value: Option<i32>,
}

impl ApplyDbIdx128EndResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx128EndResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx128EndResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx128EndResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx128End"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256StoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256StoreArgs {
  scope: Uint64,
  table: Uint64,
  payer: Uint64,
  id: Uint64,
  data: Vec<u8>,
}

impl ApplyDbIdx256StoreArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256StoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256StoreArgs.scope", &f_1)?;
    verify_required_field_exists("ApplyDbIdx256StoreArgs.table", &f_2)?;
    verify_required_field_exists("ApplyDbIdx256StoreArgs.payer", &f_3)?;
    verify_required_field_exists("ApplyDbIdx256StoreArgs.id", &f_4)?;
    verify_required_field_exists("ApplyDbIdx256StoreArgs.data", &f_5)?;
    let ret = ApplyDbIdx256StoreArgs {
      scope: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table: f_2.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      data: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_store_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 1))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 2))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 3))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 5))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256StoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256StoreResult {
  result_value: Option<i32>,
}

impl ApplyDbIdx256StoreResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256StoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256StoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256StoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256Store"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256UpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256UpdateArgs {
  iterator: i32,
  payer: Uint64,
  data: Vec<u8>,
}

impl ApplyDbIdx256UpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256UpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256UpdateArgs.iterator", &f_1)?;
    verify_required_field_exists("ApplyDbIdx256UpdateArgs.payer", &f_2)?;
    verify_required_field_exists("ApplyDbIdx256UpdateArgs.data", &f_3)?;
    let ret = ApplyDbIdx256UpdateArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 2))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 3))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256UpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256UpdateResult {
}

impl ApplyDbIdx256UpdateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256UpdateResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256UpdateResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256UpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdx256RemoveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256RemoveArgs {
  iterator: i32,
}

impl ApplyDbIdx256RemoveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256RemoveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256RemoveArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx256RemoveArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_remove_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256RemoveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256RemoveResult {
}

impl ApplyDbIdx256RemoveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256RemoveResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256RemoveResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256RemoveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdx256NextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256NextArgs {
  iterator: i32,
}

impl ApplyDbIdx256NextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256NextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256NextArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx256NextArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_next_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256NextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256NextResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdx256NextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256NextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256NextResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256NextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256Next"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256PreviousArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256PreviousArgs {
  iterator: i32,
}

impl ApplyDbIdx256PreviousArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256PreviousArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256PreviousArgs.iterator", &f_1)?;
    let ret = ApplyDbIdx256PreviousArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_previous_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256PreviousResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256PreviousResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdx256PreviousResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256PreviousResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256PreviousResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256PreviousResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256Previous"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256FindPrimaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256FindPrimaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  primary: Uint64,
}

impl ApplyDbIdx256FindPrimaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256FindPrimaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256FindPrimaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx256FindPrimaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx256FindPrimaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx256FindPrimaryArgs.primary", &f_4)?;
    let ret = ApplyDbIdx256FindPrimaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_find_primary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 4))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256FindPrimaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256FindPrimaryResult {
  result_value: Option<FindPrimaryReturn>,
}

impl ApplyDbIdx256FindPrimaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256FindPrimaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindPrimaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindPrimaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256FindPrimaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256FindPrimaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindPrimaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256FindPrimary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256FindSecondaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256FindSecondaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  data: Vec<u8>,
}

impl ApplyDbIdx256FindSecondaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256FindSecondaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256FindSecondaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx256FindSecondaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx256FindSecondaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx256FindSecondaryArgs.data", &f_4)?;
    let ret = ApplyDbIdx256FindSecondaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      data: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_find_secondary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 4))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256FindSecondaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256FindSecondaryResult {
  result_value: Option<FindSecondaryReturn>,
}

impl ApplyDbIdx256FindSecondaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256FindSecondaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindSecondaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindSecondaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256FindSecondaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256FindSecondaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindSecondaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256FindSecondary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256LowerboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256LowerboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  data: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdx256LowerboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256LowerboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256LowerboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx256LowerboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx256LowerboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx256LowerboundArgs.data", &f_4)?;
    verify_required_field_exists("ApplyDbIdx256LowerboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdx256LowerboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_lowerbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 4))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256LowerboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256LowerboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdx256LowerboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256LowerboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256LowerboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256LowerboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256Lowerbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256UpperboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256UpperboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  data: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdx256UpperboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256UpperboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256UpperboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx256UpperboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx256UpperboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdx256UpperboundArgs.data", &f_4)?;
    verify_required_field_exists("ApplyDbIdx256UpperboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdx256UpperboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_upperbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 4))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256UpperboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256UpperboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdx256UpperboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256UpperboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256UpperboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256UpperboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256Upperbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdx256EndArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256EndArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
}

impl ApplyDbIdx256EndArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256EndArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdx256EndArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdx256EndArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdx256EndArgs.table", &f_3)?;
    let ret = ApplyDbIdx256EndArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx256_end_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdx256EndResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdx256EndResult {
  result_value: Option<i32>,
}

impl ApplyDbIdx256EndResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdx256EndResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdx256EndResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdx256EndResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdx256End"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoubleStoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleStoreArgs {
  scope: Uint64,
  table: Uint64,
  payer: Uint64,
  id: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdxDoubleStoreArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleStoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleStoreArgs.scope", &f_1)?;
    verify_required_field_exists("ApplyDbIdxDoubleStoreArgs.table", &f_2)?;
    verify_required_field_exists("ApplyDbIdxDoubleStoreArgs.payer", &f_3)?;
    verify_required_field_exists("ApplyDbIdxDoubleStoreArgs.id", &f_4)?;
    verify_required_field_exists("ApplyDbIdxDoubleStoreArgs.secondary", &f_5)?;
    let ret = ApplyDbIdxDoubleStoreArgs {
      scope: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table: f_2.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_store_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 1))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 2))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 3))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 5))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleStoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleStoreResult {
  result_value: Option<i32>,
}

impl ApplyDbIdxDoubleStoreResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleStoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleStoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleStoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoubleStore"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoubleUpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleUpdateArgs {
  iterator: i32,
  payer: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdxDoubleUpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleUpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleUpdateArgs.iterator", &f_1)?;
    verify_required_field_exists("ApplyDbIdxDoubleUpdateArgs.payer", &f_2)?;
    verify_required_field_exists("ApplyDbIdxDoubleUpdateArgs.secondary", &f_3)?;
    let ret = ApplyDbIdxDoubleUpdateArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 2))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 3))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleUpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleUpdateResult {
}

impl ApplyDbIdxDoubleUpdateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleUpdateResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleUpdateResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleUpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdxDoubleRemoveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleRemoveArgs {
  iterator: i32,
}

impl ApplyDbIdxDoubleRemoveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleRemoveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleRemoveArgs.iterator", &f_1)?;
    let ret = ApplyDbIdxDoubleRemoveArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_remove_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleRemoveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleRemoveResult {
}

impl ApplyDbIdxDoubleRemoveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleRemoveResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleRemoveResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleRemoveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdxDoubleNextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleNextArgs {
  iterator: i32,
}

impl ApplyDbIdxDoubleNextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleNextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleNextArgs.iterator", &f_1)?;
    let ret = ApplyDbIdxDoubleNextArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_next_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleNextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleNextResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdxDoubleNextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleNextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleNextResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleNextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoubleNext"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoublePreviousArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoublePreviousArgs {
  iterator: i32,
}

impl ApplyDbIdxDoublePreviousArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoublePreviousArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoublePreviousArgs.iterator", &f_1)?;
    let ret = ApplyDbIdxDoublePreviousArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_previous_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoublePreviousResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoublePreviousResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdxDoublePreviousResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoublePreviousResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoublePreviousResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoublePreviousResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoublePrevious"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoubleFindPrimaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleFindPrimaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  primary: Uint64,
}

impl ApplyDbIdxDoubleFindPrimaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleFindPrimaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleFindPrimaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxDoubleFindPrimaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxDoubleFindPrimaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxDoubleFindPrimaryArgs.primary", &f_4)?;
    let ret = ApplyDbIdxDoubleFindPrimaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_find_primary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 4))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleFindPrimaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleFindPrimaryResult {
  result_value: Option<FindPrimaryReturn>,
}

impl ApplyDbIdxDoubleFindPrimaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleFindPrimaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindPrimaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindPrimaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleFindPrimaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleFindPrimaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindPrimaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoubleFindPrimary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoubleFindSecondaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleFindSecondaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdxDoubleFindSecondaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleFindSecondaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleFindSecondaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxDoubleFindSecondaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxDoubleFindSecondaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxDoubleFindSecondaryArgs.secondary", &f_4)?;
    let ret = ApplyDbIdxDoubleFindSecondaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_find_secondary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleFindSecondaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleFindSecondaryResult {
  result_value: Option<FindSecondaryReturn>,
}

impl ApplyDbIdxDoubleFindSecondaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleFindSecondaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindSecondaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindSecondaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleFindSecondaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleFindSecondaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindSecondaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoubleFindSecondary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoubleLowerboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleLowerboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdxDoubleLowerboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleLowerboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleLowerboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxDoubleLowerboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxDoubleLowerboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxDoubleLowerboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdxDoubleLowerboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdxDoubleLowerboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_lowerbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleLowerboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleLowerboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdxDoubleLowerboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleLowerboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleLowerboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleLowerboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoubleLowerbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoubleUpperboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleUpperboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdxDoubleUpperboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleUpperboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleUpperboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxDoubleUpperboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxDoubleUpperboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxDoubleUpperboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdxDoubleUpperboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdxDoubleUpperboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_upperbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleUpperboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleUpperboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdxDoubleUpperboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleUpperboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleUpperboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleUpperboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoubleUpperbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxDoubleEndArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleEndArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
}

impl ApplyDbIdxDoubleEndArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleEndArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxDoubleEndArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxDoubleEndArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxDoubleEndArgs.table", &f_3)?;
    let ret = ApplyDbIdxDoubleEndArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_double_end_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxDoubleEndResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxDoubleEndResult {
  result_value: Option<i32>,
}

impl ApplyDbIdxDoubleEndResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxDoubleEndResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxDoubleEndResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxDoubleEndResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxDoubleEnd"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoubleStoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleStoreArgs {
  scope: Uint64,
  table: Uint64,
  payer: Uint64,
  id: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdxLongDoubleStoreArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleStoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    let mut f_5: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleStoreArgs.scope", &f_1)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleStoreArgs.table", &f_2)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleStoreArgs.payer", &f_3)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleStoreArgs.id", &f_4)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleStoreArgs.secondary", &f_5)?;
    let ret = ApplyDbIdxLongDoubleStoreArgs {
      scope: f_1.expect("auto-generated code should have checked for presence of required fields"),
      table: f_2.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_store_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 1))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 2))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 3))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::Struct, 4))?;
    self.id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 5))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleStoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleStoreResult {
  result_value: Option<i32>,
}

impl ApplyDbIdxLongDoubleStoreResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleStoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleStoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleStoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoubleStore"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoubleUpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleUpdateArgs {
  iterator: i32,
  payer: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdxLongDoubleUpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleUpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpdateArgs.iterator", &f_1)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpdateArgs.payer", &f_2)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpdateArgs.secondary", &f_3)?;
    let ret = ApplyDbIdxLongDoubleUpdateArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
      payer: f_2.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("payer", TType::Struct, 2))?;
    self.payer.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 3))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleUpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleUpdateResult {
}

impl ApplyDbIdxLongDoubleUpdateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleUpdateResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleUpdateResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleUpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdxLongDoubleRemoveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleRemoveArgs {
  iterator: i32,
}

impl ApplyDbIdxLongDoubleRemoveArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleRemoveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleRemoveArgs.iterator", &f_1)?;
    let ret = ApplyDbIdxLongDoubleRemoveArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_remove_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleRemoveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleRemoveResult {
}

impl ApplyDbIdxLongDoubleRemoveResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleRemoveResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleRemoveResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleRemoveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyDbIdxLongDoubleNextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleNextArgs {
  iterator: i32,
}

impl ApplyDbIdxLongDoubleNextArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleNextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleNextArgs.iterator", &f_1)?;
    let ret = ApplyDbIdxLongDoubleNextArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_next_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleNextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleNextResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdxLongDoubleNextResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleNextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleNextResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleNextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoubleNext"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoublePreviousArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoublePreviousArgs {
  iterator: i32,
}

impl ApplyDbIdxLongDoublePreviousArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoublePreviousArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoublePreviousArgs.iterator", &f_1)?;
    let ret = ApplyDbIdxLongDoublePreviousArgs {
      iterator: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_previous_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iterator", TType::I32, 1))?;
    o_prot.write_i32(self.iterator)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoublePreviousResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoublePreviousResult {
  result_value: Option<NextPreviousReturn>,
}

impl ApplyDbIdxLongDoublePreviousResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoublePreviousResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<NextPreviousReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = NextPreviousReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoublePreviousResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoublePreviousResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<NextPreviousReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoublePrevious"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoubleFindPrimaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleFindPrimaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  primary: Uint64,
}

impl ApplyDbIdxLongDoubleFindPrimaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleFindPrimaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindPrimaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindPrimaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindPrimaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindPrimaryArgs.primary", &f_4)?;
    let ret = ApplyDbIdxLongDoubleFindPrimaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_find_primary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 4))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleFindPrimaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleFindPrimaryResult {
  result_value: Option<FindPrimaryReturn>,
}

impl ApplyDbIdxLongDoubleFindPrimaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleFindPrimaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindPrimaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindPrimaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleFindPrimaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleFindPrimaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindPrimaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoubleFindPrimary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoubleFindSecondaryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleFindSecondaryArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
}

impl ApplyDbIdxLongDoubleFindSecondaryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleFindSecondaryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindSecondaryArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindSecondaryArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindSecondaryArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleFindSecondaryArgs.secondary", &f_4)?;
    let ret = ApplyDbIdxLongDoubleFindSecondaryArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_find_secondary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleFindSecondaryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleFindSecondaryResult {
  result_value: Option<FindSecondaryReturn>,
}

impl ApplyDbIdxLongDoubleFindSecondaryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleFindSecondaryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FindSecondaryReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FindSecondaryReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleFindSecondaryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleFindSecondaryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FindSecondaryReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoubleFindSecondary"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoubleLowerboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleLowerboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdxLongDoubleLowerboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleLowerboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleLowerboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleLowerboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleLowerboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleLowerboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleLowerboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdxLongDoubleLowerboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_lowerbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleLowerboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleLowerboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdxLongDoubleLowerboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleLowerboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleLowerboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleLowerboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoubleLowerbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoubleUpperboundArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleUpperboundArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
  secondary: Vec<u8>,
  primary: Uint64,
}

impl ApplyDbIdxLongDoubleUpperboundArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleUpperboundArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpperboundArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpperboundArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpperboundArgs.table", &f_3)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpperboundArgs.secondary", &f_4)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleUpperboundArgs.primary", &f_5)?;
    let ret = ApplyDbIdxLongDoubleUpperboundArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
      secondary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      primary: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_upperbound_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secondary", TType::String, 4))?;
    o_prot.write_bytes(&self.secondary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("primary", TType::Struct, 5))?;
    self.primary.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleUpperboundResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleUpperboundResult {
  result_value: Option<LowerBoundUpperBoundReturn>,
}

impl ApplyDbIdxLongDoubleUpperboundResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleUpperboundResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<LowerBoundUpperBoundReturn> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = LowerBoundUpperBoundReturn::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleUpperboundResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleUpperboundResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<LowerBoundUpperBoundReturn> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoubleUpperbound"
          )
        )
      )
    }
  }
}

//
// ApplyDbIdxLongDoubleEndArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleEndArgs {
  code: Uint64,
  scope: Uint64,
  table: Uint64,
}

impl ApplyDbIdxLongDoubleEndArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleEndArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<Uint64> = None;
    let mut f_3: Option<Uint64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyDbIdxLongDoubleEndArgs.code", &f_1)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleEndArgs.scope", &f_2)?;
    verify_required_field_exists("ApplyDbIdxLongDoubleEndArgs.table", &f_3)?;
    let ret = ApplyDbIdxLongDoubleEndArgs {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scope: f_2.expect("auto-generated code should have checked for presence of required fields"),
      table: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("db_idx_long_double_end_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::Struct, 1))?;
    self.code.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::Struct, 2))?;
    self.scope.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("table", TType::Struct, 3))?;
    self.table.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyDbIdxLongDoubleEndResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyDbIdxLongDoubleEndResult {
  result_value: Option<i32>,
}

impl ApplyDbIdxLongDoubleEndResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyDbIdxLongDoubleEndResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyDbIdxLongDoubleEndResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyDbIdxLongDoubleEndResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyDbIdxLongDoubleEnd"
          )
        )
      )
    }
  }
}

//
// ApplySetActionReturnValueArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetActionReturnValueArgs {
  data: Vec<u8>,
}

impl ApplySetActionReturnValueArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetActionReturnValueArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySetActionReturnValueArgs.data", &f_1)?;
    let ret = ApplySetActionReturnValueArgs {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("set_action_return_value_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySetActionReturnValueResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySetActionReturnValueResult {
}

impl ApplySetActionReturnValueResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySetActionReturnValueResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySetActionReturnValueResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySetActionReturnValueResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// ApplyGetCodeHashArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetCodeHashArgs {
  account: Uint64,
  struct_version: i64,
}

impl ApplyGetCodeHashArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetCodeHashArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Uint64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Uint64::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyGetCodeHashArgs.account", &f_1)?;
    verify_required_field_exists("ApplyGetCodeHashArgs.struct_version", &f_2)?;
    let ret = ApplyGetCodeHashArgs {
      account: f_1.expect("auto-generated code should have checked for presence of required fields"),
      struct_version: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_code_hash_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("account", TType::Struct, 1))?;
    self.account.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("struct_version", TType::I64, 2))?;
    o_prot.write_i64(self.struct_version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetCodeHashResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetCodeHashResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyGetCodeHashResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetCodeHashResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetCodeHashResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetCodeHashResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetCodeHash"
          )
        )
      )
    }
  }
}

//
// ApplyGetBlockNumArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetBlockNumArgs {
}

impl ApplyGetBlockNumArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetBlockNumArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetBlockNumArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("get_block_num_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyGetBlockNumResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyGetBlockNumResult {
  result_value: Option<i64>,
}

impl ApplyGetBlockNumResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyGetBlockNumResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyGetBlockNumResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyGetBlockNumResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyGetBlockNum"
          )
        )
      )
    }
  }
}

//
// ApplySha3Args
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha3Args {
  data: Vec<u8>,
  keccak: i32,
}

impl ApplySha3Args {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha3Args> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplySha3Args.data", &f_1)?;
    verify_required_field_exists("ApplySha3Args.keccak", &f_2)?;
    let ret = ApplySha3Args {
      data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      keccak: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sha3_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::String, 1))?;
    o_prot.write_bytes(&self.data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("keccak", TType::I32, 2))?;
    o_prot.write_i32(self.keccak)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplySha3Result
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplySha3Result {
  result_value: Option<Vec<u8>>,
}

impl ApplySha3Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplySha3Result> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplySha3Result {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplySha3Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplySha3"
          )
        )
      )
    }
  }
}

//
// ApplyBlake2FArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyBlake2FArgs {
  rounds: i64,
  state: Vec<u8>,
  msg: Vec<u8>,
  t0_offset: Vec<u8>,
  t1_offset: Vec<u8>,
  final_: i32,
}

impl ApplyBlake2FArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyBlake2FArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<u8>> = None;
    let mut f_3: Option<Vec<u8>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Vec<u8>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyBlake2FArgs.rounds", &f_1)?;
    verify_required_field_exists("ApplyBlake2FArgs.state", &f_2)?;
    verify_required_field_exists("ApplyBlake2FArgs.msg", &f_3)?;
    verify_required_field_exists("ApplyBlake2FArgs.t0_offset", &f_4)?;
    verify_required_field_exists("ApplyBlake2FArgs.t1_offset", &f_5)?;
    verify_required_field_exists("ApplyBlake2FArgs.final_", &f_6)?;
    let ret = ApplyBlake2FArgs {
      rounds: f_1.expect("auto-generated code should have checked for presence of required fields"),
      state: f_2.expect("auto-generated code should have checked for presence of required fields"),
      msg: f_3.expect("auto-generated code should have checked for presence of required fields"),
      t0_offset: f_4.expect("auto-generated code should have checked for presence of required fields"),
      t1_offset: f_5.expect("auto-generated code should have checked for presence of required fields"),
      final_: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("blake2_f_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rounds", TType::I64, 1))?;
    o_prot.write_i64(self.rounds)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::String, 2))?;
    o_prot.write_bytes(&self.state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("msg", TType::String, 3))?;
    o_prot.write_bytes(&self.msg)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("t0_offset", TType::String, 4))?;
    o_prot.write_bytes(&self.t0_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("t1_offset", TType::String, 5))?;
    o_prot.write_bytes(&self.t1_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("final", TType::I32, 6))?;
    o_prot.write_i32(self.final_)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyBlake2FResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyBlake2FResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyBlake2FResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyBlake2FResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyBlake2FResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyBlake2FResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyBlake2F"
          )
        )
      )
    }
  }
}

//
// ApplyK1RecoverArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyK1RecoverArgs {
  sig: Vec<u8>,
  dig: Vec<u8>,
}

impl ApplyK1RecoverArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyK1RecoverArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyK1RecoverArgs.sig", &f_1)?;
    verify_required_field_exists("ApplyK1RecoverArgs.dig", &f_2)?;
    let ret = ApplyK1RecoverArgs {
      sig: f_1.expect("auto-generated code should have checked for presence of required fields"),
      dig: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("k1_recover_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sig", TType::String, 1))?;
    o_prot.write_bytes(&self.sig)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dig", TType::String, 2))?;
    o_prot.write_bytes(&self.dig)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyK1RecoverResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyK1RecoverResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyK1RecoverResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyK1RecoverResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyK1RecoverResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyK1RecoverResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyK1Recover"
          )
        )
      )
    }
  }
}

//
// ApplyAltBn128AddArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAltBn128AddArgs {
  op1: Vec<u8>,
  op2: Vec<u8>,
}

impl ApplyAltBn128AddArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAltBn128AddArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAltBn128AddArgs.op1", &f_1)?;
    verify_required_field_exists("ApplyAltBn128AddArgs.op2", &f_2)?;
    let ret = ApplyAltBn128AddArgs {
      op1: f_1.expect("auto-generated code should have checked for presence of required fields"),
      op2: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alt_bn128_add_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("op1", TType::String, 1))?;
    o_prot.write_bytes(&self.op1)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("op2", TType::String, 2))?;
    o_prot.write_bytes(&self.op2)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAltBn128AddResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAltBn128AddResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyAltBn128AddResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAltBn128AddResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAltBn128AddResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAltBn128AddResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyAltBn128Add"
          )
        )
      )
    }
  }
}

//
// ApplyAltBn128MulArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAltBn128MulArgs {
  g1: Vec<u8>,
  scalar: Vec<u8>,
}

impl ApplyAltBn128MulArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAltBn128MulArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAltBn128MulArgs.g1", &f_1)?;
    verify_required_field_exists("ApplyAltBn128MulArgs.scalar", &f_2)?;
    let ret = ApplyAltBn128MulArgs {
      g1: f_1.expect("auto-generated code should have checked for presence of required fields"),
      scalar: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alt_bn128_mul_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("g1", TType::String, 1))?;
    o_prot.write_bytes(&self.g1)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scalar", TType::String, 2))?;
    o_prot.write_bytes(&self.scalar)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAltBn128MulResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAltBn128MulResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyAltBn128MulResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAltBn128MulResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAltBn128MulResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAltBn128MulResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyAltBn128Mul"
          )
        )
      )
    }
  }
}

//
// ApplyAltBn128PairArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAltBn128PairArgs {
  pairs: Vec<u8>,
}

impl ApplyAltBn128PairArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAltBn128PairArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyAltBn128PairArgs.pairs", &f_1)?;
    let ret = ApplyAltBn128PairArgs {
      pairs: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("alt_bn128_pair_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pairs", TType::String, 1))?;
    o_prot.write_bytes(&self.pairs)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyAltBn128PairResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyAltBn128PairResult {
  result_value: Option<i32>,
}

impl ApplyAltBn128PairResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyAltBn128PairResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyAltBn128PairResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyAltBn128PairResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyAltBn128Pair"
          )
        )
      )
    }
  }
}

//
// ApplyModExpArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyModExpArgs {
  base: Vec<u8>,
  exp: Vec<u8>,
  mod_: Vec<u8>,
}

impl ApplyModExpArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyModExpArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<u8>> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ApplyModExpArgs.base", &f_1)?;
    verify_required_field_exists("ApplyModExpArgs.exp", &f_2)?;
    verify_required_field_exists("ApplyModExpArgs.mod_", &f_3)?;
    let ret = ApplyModExpArgs {
      base: f_1.expect("auto-generated code should have checked for presence of required fields"),
      exp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      mod_: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("mod_exp_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("base", TType::String, 1))?;
    o_prot.write_bytes(&self.base)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("exp", TType::String, 2))?;
    o_prot.write_bytes(&self.exp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mod", TType::String, 3))?;
    o_prot.write_bytes(&self.mod_)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyModExpResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ApplyModExpResult {
  result_value: Option<Vec<u8>>,
}

impl ApplyModExpResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyModExpResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bytes()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyModExpResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyModExpResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<u8>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ApplyModExp"
          )
        )
      )
    }
  }
}

